{"pageContext":{"html":"<p><a href=\"ctf=csaw-finals-2016\"></a>\n<a href=\"type=reverse\"></a>\n<a href=\"tags=z3,%20constraint%20solving\"></a>\n<a href=\"tools=z3\"></a>\n<a href=\"techniques=constraint%20solving,%20symbolic%20execution\"></a></p>\n<h1>packer (rev-250)</h1>\n<p>We are given a <a href=\"/packer-release-f382f28f0f43ffa92691b68aaf5006e8.\">file</a></p>\n<pre><code class=\"language-bash\">$file packer-release\npacker-release: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=30e7a8e386f33bb6bdf8a7701d7169584f9db7a9, stripped\n</code></pre>\n<p>Opening it in hopper gives a pretty neat decompilation.</p>\n<pre><code class=\"language-c\">main() {\n    esi = arg1;\n    if (arg0 == 0x2) {\n            eax = malloc(0x1f);\n            ebx = eax;\n            *0x804a034 = eax;\n            eax = *(esi + 0x4);\n            strncpy(ebx, eax, 0x1f);\n            *(int8_t *)(ebx + 0x1e) = 0x0;\n            edx = *(ebx + 0xd);\n            eax = *(ebx + 0x15);\n            if (eax + edx == 0xe1d4e090) {\n                    *0x804a030 = *0x804a030 ^ 0xb93e4867;\n            }\n            if (eax + *(ebx + 0x19) == 0x94e860d0) {\n                    *0x804a030 = *0x804a030 ^ 0xb9f7a2ff;\n            }\n            esi = *(ebx + 0x9);\n            if (esi + eax == 0xcdd6d8c1) {\n                    *0x804a030 = *0x804a030 ^ 0x7e3c14cd;\n            }\n            ecx = *(ebx + 0x11);\n            if (ecx + *(ebx + 0x5) == 0x93e1a69f) {\n                    *0x804a030 = *0x804a030 ^ 0x21ddc691;\n            }\n            if (esi + edx == 0xcd929799) {\n                    *0x804a030 = *0x804a030 ^ 0x65aafd58;\n            }\n            if (eax + ecx == 0x9fa6cfd3) {\n                    *0x804a030 = *0x804a030 ^ 0x372f660e;\n            }\n            if (edx + ecx == 0xa490e3a5) {\n                    *0x804a030 = *0x804a030 ^ 0xcbff9345;\n            }\n            sub_8048513();\n            eax = *0x804a034;\n            ecx = *(eax + 0x5);\n            edx = *(eax + 0x19);\n            esi = edx + ecx;\n            if (esi == 0x55dc64d0) {\n                    *0x804a030 = *0x804a030 ^ 0x453057e3;\n            }\n            edi = *(*0x804a034 + 0x11);\n            if (edi + edx == 0x5261e2d3) {\n                    *0x804a030 = *0x804a030 ^ 0xe8d28fd7;\n            }\n            ebx = *(*0x804a034 + 0x9);\n            if (edi + ebx == 0xcdd8a69f) {\n                    *0x804a030 = *0x804a030 ^ 0xce71dd4a;\n            }\n            if (esi == 0x5497e5c0) {\n                    *0x804a030 = *0x804a030 ^ 0xc30b088b;\n            }\n            esi = *(*0x804a034 + 0xd);\n            if (esi + ecx == 0x939b9799) {\n                    *0x804a030 = *0x804a030 ^ 0xb2c58526;\n            }\n            if (ecx + *(*0x804a034 + 0x15) == 0xa1dcd2c0) {\n                    *0x804a030 = *0x804a030 ^ 0xa47e904c;\n            }\n            if (ebx + edx == 0x8fd364d0) {\n                    *0x804a030 = *0x804a030 ^ 0x4d663570;\n            }\n            if (ecx + ebx == 0x92c8dec3) {\n                    *0x804a030 = *0x804a030 ^ 0x5f3ceee9;\n            }\n            if (edx + esi == 0x80a79399) {\n                    *0x804a030 = *0x804a030 ^ 0xbd87bd77;\n            }\n            if (*0x804a030 == 0xdeadbea7) {\n                    eax = sub_80484f0();\n            }\n            else {\n                    eax = sub_80484cd();\n            }\n    }\n    else {\n            stack[2042] = *esi;\n            __printf_chk(0x1, \"usage: %s flag\\n\", stack[2042]);\n            eax = 0xffffffff;\n    }\n    return eax;\n}\n\nsub_8048513() {\n    if ((((*(int8_t *)(*0x804a034 + 0x4) == 0x7b) &#x26;&#x26; (*(int8_t *)(*0x804a034 + 0x2) == 0x61)) &#x26;&#x26; (*(int8_t *)(*0x804a034 + 0x1) == 0x6c)) &#x26;&#x26; (*(int8_t *)*0x804a034 == 0x66)) {\n            if (*(int8_t *)(*0x804a034 + 0x3) == 0x67) {\n                    if (*(int8_t *)(*0x804a034 + 0x1d) == 0x7d) {\n                            *0x804a030 = *0x804a030 ^ 0x35e4eebf;\n                    }\n            }\n    }\n    return *0x804a034;\n}\n</code></pre>\n<p>The logic is pretty straight forward. main() checks if the flag is in argv[1] and then checks the constraints on it. sub_8048513() checks if the flag is of format flag{ %s} and then sets *0x804a030=0x35E4EEBF.</p>\n<p>Its very easy to figure out the constraints here. 0x804a030 stores a xor checksum which should be equal to 0xdeadbea7 for the correct flag.</p>\n<p>Since the remote hosts given to us were not so powerful to run angr and we did not have root on the local machines, I used z3 model this binary from the decompilation produced by hopper <a href=\"/rev250-05ba908739a21836392d848947b2ddf6.py\">here</a>.</p>\n<pre><code class=\"language-python\">from z3 import *\n\nfor i in xrange(6):\n    globals()['a%i' % i]=BitVec('a%i' %i,32)\n\nfor i in xrange(16):\n    globals()['xor_%i' % i]=BitVec('xor_%i' %i,32)\n\nsolver=Solver()\n\ncons=[a2+a4 == 0xE1D4E090,a5+a4 == 0x94E860D0,a1+a4 == 0xCDD6D8C1,a0+a3 == 0x93E1A69F,a1+a2 == 0xCD929799,a3+a4 == 0x9FA6CFD3,a2+a3 == 0xA490E3A5,a0+a5 == 1440507088,a5+a3 == 1382146771,a1+a3 == 0xCDD8A69F,a0+a5 == 1419240896,a0+a2 == 0x939B9799,a4+a0 == 0xA1DCD2C0,a1+a5 == 0x8FD364D0,a1+a0 == 0x92C8DEC3,a2+a5 == 0x80A79399]\nxor_a=[0xB93E4867,0xB9F7A2FF,0x7E3C14CD,0x21DDC691,0x65AAFD58,0x372F660E,0xCBFF9345,0x453057E3,0xE8D28FD7,0xCE71DD4A,0xC30B088B,0xB2C58526,0xA47E904C,0x4D663570,0x5F3CEEE9,0xBD87BD77]\n\nfor i in xrange(16):\n    globals()['xor_%i' % i]=xor_a[i]\n\nxor_w=BitVecVal(0x35E4EEBF,32)\n\ntemp=BitVec('temp',32)\n\nfor i in xrange(16):\n    temp=xor_w^globals()['xor_%i' % i]\n    xor_w=If((cons[i]),temp,xor_w)\n\nsolver.add(xor_w == 0xDEADBEA7)\n\nprint solver.check()\n\nmodl=solver.model()\n\nres=\"\"\nfor i in xrange(6):\n    obj=globals()['a%i' % i]\n    c=modl[obj].as_long()\n    res += hex(c)[2:].decode('hex')[::-1]\n\nprint(\"Result: flag{ %s}\"%res)\n</code></pre>\n<p>gives us flag{alg3bra<em>1z</em>sti11<em>fun</em>y0!} in no time.</p>"}}