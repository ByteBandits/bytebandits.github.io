{"pageContext":{"html":"<p><a href=\"ctf=csaw-finals-2018\"></a>\n<a href=\"type=reverse\"></a>\n<a href=\"tags=tree\"></a>\n<a href=\"tools=ida,%20r2\"></a></p>\n<h1>kvm (rev-500)</h1>\n<pre><code>Reversing\nkvm\n\nWe found a mysterious program that none of our most talented hackers could even begin to figure out.\n\nAuthor: toshi\n\nSolves: 58\n</code></pre>\n<p>We are given a <a href=\"../chall-500-kvm.elf\">file</a></p>\n<p>This sets up a vm and a vcpu using KVM apis. An area is mmaped between both machines loaded at 0x0 in guest. Then <code>_payload</code> from the binary is copied to this area and <code>rip</code> is set to 0. This means code for vm begins at <code>0x202174</code> and probably ends at <code>0x20348C</code></p>\n<p>Code at <code>0x202174</code> is quite straight forward:</p>\n<p><img src=\"start_vm.png\" alt=\"0x202174\"></p>\n<p>First it reads 0x2800 bytes, then it calls <code>process_byte</code> on every byte. This call should return 1 otherwise it goes to \"Wrong\" message. Aftet this <code>memcmp</code> is called to match two memory regions at addresses <code>0x1320</code> and <code>0x580</code> which also decide Correct/Wrong message.</p>\n<h4>process_byte</h4>\n<p>This is where the challenge starts. First basic block comes to an abrupt <code>hlt</code></p>\n<p><img src=\"process_byte.png\" alt=\"process_byte\"></p>\n<p>Looking at the function that starts the VM with KVM_RUN, there's a handler to handle IO and check when machine halts;</p>\n<pre><code class=\"language-c\">if ( ioctl(*(_DWORD *)a2, 0x8090AE81uLL, &#x26;v7) &#x3C; 0 )\n {\n   perror(\"KVM_GET_REGS\");\n   exit(1);\n }\n result = v7.rax;\n if ( !v7.rax )\n   return result;\n v4 = jumper_fn(v7.rax);\n v7.rip = v4;\n if ( ioctl(*(_DWORD *)a2, 0x4090AE82uLL, &#x26;v7) &#x3C; 0 )\n {\n   perror(\"KVM_SET_REGS\");\n   exit(1);\n }\n\n __int64 __fastcall jumper_fn(int a1)\n{\n  __int64 *v1; // rdx\n  __int64 v2; // rdx\n  __int64 result; // rax\n  int i; // [rsp+1Ch] [rbp-14h]\n\n  for ( i = 0; ; ++i )\n  {\n    if ( i >= dword_202170 )\n    {\n      fwrite(\"Error - bug the organizer\\n\", 1uLL, 0x1AuLL, stderr);\n      exit(1);\n    }\n    if ( LODWORD(qword_2020A0[2 * i]) == a1 )\n      break;\n  }\n  v1 = &#x26;qword_2020A0[2 * i];\n  result = *v1;\n  v2 = v1[1];\n  return (unsigned int)result;\n}\n</code></pre>\n<p>Based on what <code>rax\\eax</code> contains <code>rip</code> is updated to new value in the vm according to</p>\n<pre><code class=\"language-python\">   {\n    0xC50B6060: 0x454\n    0x9D1FE433: 0x3ED\n    0x54A15B03: 0x376\n    0x8F6E2804: 0x422\n    0x8AEEF509: 0x389\n    0x3493310D: 0x32C\n    0x59C33D0F: 0x3E1\n    0x968630D0: 0x400\n    0xEF5BDD13: 0x435\n    0x64D8A529: 0x3B8\n    0x5F291A64: 0x441\n    0x05DE72DD: 0x347\n    0xFC2FF49F: 0x3CE\n    }\n</code></pre>\n<p>This opens up a lot of code to analyze with similar  <code>mov eax, const; hlt</code> pattern.\nI use a little r2 and dot to generate this file to look at the code easily.</p>\n<p><img src=\"graph.png\" alt=\"cfg\"></p>\n<p>Now we can ignore <code>hlt</code> and consider this as one function with the following pseudocode</p>\n<pre><code class=\"language-python\">def process_byte(byte, idx):\n    c = some_arr[idx]\n    if c == 0xff:\n        t = process_byte(byte, idx+8)\n        if t == 1:\n            write_bit(0)\n            return 1\n        else:\n            t = process_byte(byte, idx+0x10)\n            if t == 1:\n                write_bit(1)\n                return 1\n    else:\n        if byte == c:\n            return 1\n        else:\n            return 0\n</code></pre>\n<p>This is basically like a dfs search for the byte provided. Based on where the byte is found in the tree <code>write_bit</code> is called with <code>1\\0</code> which writes the bit to 0x1320.\n0x1320 is used in <code>memcmp</code> to determine the correct/wrong.</p>\n<p>The tree root is at address <code>0x203474</code> which is (0x1300+0x202174) as <code>process_byte</code> is always called from <code>start_vm</code> as <code>process_byte(byte, 0x1300)</code></p>\n<p>The problem now is given some data and the ability to write 1/0 to other region, we make them match.</p>\n<p>The tree looks like this:</p>\n<p><img src=\"nodes.png\" alt=\"node\"></p>\n<p>Based on whether a right/left is taken to traverse to the leaf node a 1/0 is written respectively. This way we can write to</p>\n<p>Now we have some bitstrings for each leaf node and the final bit string to be written, we need to find the right order that will fit in 0x2800 bytes.</p>\n<pre><code class=\"language-python\">  {\n  '0001110': '4'\n  '11111010': 'e'\n  '110110': '6'\n  '0001010': '?'\n  '00111010': '\\n'\n  '1011010': 'r'\n  '10100': 'o'\n  '000010': '3'\n  '01100': '1'\n  '1101010': 'd'\n  '1101110': 'u'\n  '1': '\\x00'\n  '100010': '7'\n  '1100100': '5'\n  '110010': 'i'\n  '010010': 'f'\n  '10000110': 'n'\n  '0011010': 'g'\n  '010110': 's'\n  '11000110': '{'\n  '000': '0'\n  '00000110': 'm'\n  '01111010': '2'\n  '10111010': '.'\n  '01000110': 'x'\n  '0100100': '}'\n  '0101110': 'l'\n  '11100': 't'\n  '100110': 'a'\n  '0101010': 'b'\n  '000100': 'w'\n  '1001110': 'h'\n  '1001010': 'c'\n  '11110': ' '\n  }\n</code></pre>\n<p>This is similar to word break problem and can be solved recursively/dp.\nDump the reference memory region <code>0x580</code> of length <code>0x54a</code> and solve.</p>\n<pre><code class=\"language-python\">dump = open(\"dump\", \"rb\").read()\ns = \"\".join(map(lambda x:format(x, '08b')[::-1], map(ord, list(dump))))\n\ndef solve(str, n, result):\n    for i in xrange(1,n+1):\n        substr = str[:i]\n        if substr in smi:\n            if i == n:\n                result += substr\n                print result\n                break\n            solve(str[i:], n-i, result+substr+\" \")\n\nsolve(s, len(s), \"\")\n</code></pre>\n<p>The string that was generated was a TAR archive with the flag.\n<a href=\"solve.py\">Full script</a></p>"}}