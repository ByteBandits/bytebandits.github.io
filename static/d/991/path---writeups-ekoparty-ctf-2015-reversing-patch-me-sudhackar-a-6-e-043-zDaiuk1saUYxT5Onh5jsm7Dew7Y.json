{"pageContext":{"html":"<p><a href=\"ctf=ekoparty-ctf-2015\"></a>\n<a href=\"type=reversing\"></a>\n<a href=\"tags=image,C#\"></a>\n<a href=\"tools=Telerik-JustDecompile,PIL\"></a>\n<a href=\"techniques=no-patch\"></a></p>\n<h1>Patch me (rev50)</h1>\n<p>We have a <a href=\"../rev50.zip\">zip</a>.\nExtract and we get</p>\n<pre><code class=\"language-bash\">$ file *\nSecureImageViewer.exe: PE32 executable (GUI) Intel 80386 Mono/.Net assembly, for MS Windows\nsecureimage.xml:       XML document text\n</code></pre>\n<p>.Net assembly can be very easy decompiled. I use <a href=\"http://www.telerik.com/products/decompiler.aspx\">Telerik JustDecompile</a> to decompile the code. Here is the code that does the main job of decoding the xml to an image.</p>\n<pre><code class=\"language-cs\">protected void open(object sender, EventArgs e)\n    {\n        int num = 201527;\n        int[] numArray = new int[100001];\n        int num1 = 0;\n        using (FileStream fileStream = File.OpenRead(\"secureimage.xml\"))\n        {\n            numArray = (int[])(new XmlSerializer(typeof(int[]))).Deserialize(fileStream);\n        }\n        for (int i = 0; i &#x3C; 100000; i++)\n        {\n            num1 = num1 + numArray[i];\n        }\n        if (num1 != numArray[100000])\n        {\n            MessageDialog messageDialog = new MessageDialog(null, 1, 3, 1, \"Corrupted Image\", new object[0]);\n            messageDialog.Run();\n            messageDialog.Destroy();\n            return;\n        }\n        GC gC = new GC(this.graph.get_GdkWindow());\n        gC.set_RgbFgColor(new Color(51, 102, 153));\n        this.graph.get_GdkWindow().GetImage(0, 0, 500, 200);\n        for (int j = 0; j &#x3C; 500; j++)\n        {\n            for (int k = 0; k &#x3C; 200; k++)\n            {\n                if ((numArray[j + k * 500] ^ num) == 3368601)\n                {\n                    this.graph.get_GdkWindow().DrawPoint(gC, j, k);\n                }\n                num = num * 100673 + 15485867;\n            }\n        }\n    }\n</code></pre>\n<p>The algorithm is easier to implement in python than to patch the binary xD.\nThe xml provided here fails the check </p>\n<pre><code>for (int i = 0; i &#x3C; 100000; i++)\n        {\n            num1 = num1 + numArray[i];\n        }\n        if (num1 != numArray[100000])\n</code></pre>\n<p>I would write python instead.</p>\n<pre><code class=\"language-python\">>>> from PIL import Image\n>>> size=500,200\n>>> num=201527\n>>> num1=0\n>>> for i in xrange(100000):\n...     num1+=arr[i]\n... \n>>> num1\n245665872900\n>>> num1=0\n>>> arr[100000]\n0\n>>> im = Image.new(\"RGB\", size, \"white\")\n>>> pix=im.load()\n>>> for j in xrange(0,500):\n...     for k in xrange(0,200):\n...             if (arr[j+k*500]^num) == 3368601:\n...                     pix[j,k]=(0,0,0)\n...             num=((num*100673)+15485867)&#x26;0xffffffff\n... \n>>> im.show()\n>>> \n</code></pre>\n<p>Will give me <img src=\"final.jpg\" alt=\"final\">.</p>\n<p>Flag</p>\n<blockquote>\n<p>EKO{n1L+P4tch}</p>\n</blockquote>"}}