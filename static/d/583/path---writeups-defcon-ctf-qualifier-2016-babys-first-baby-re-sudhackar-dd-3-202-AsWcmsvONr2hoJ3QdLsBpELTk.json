{"pageContext":{"html":"<p><a href=\"ctf=defcon-qualifier-2015\"></a>\n<a href=\"type=reverse\"></a>\n<a href=\"tags=equation-solver\"></a>\n<a href=\"tools=angr\"></a></p>\n<h1>baby-re (babys-first 1)</h1>\n<h3>~~math required~~</h3>\n<p>We are given a file</p>\n<p><code>bash $ file baby-re baby-re: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=5d5783d23d78bf70b80d658bccbce365f7448693, not stripped</code>\nTest-run</p>\n<p><code>bash $ ./baby-re Var[0]: 10 Var[1]: 10 Var[2]: 10 Var[3]: 101 Var[4]: 10 Var[5]: 10 Var[6]: 10 Var[7]: 10 Var[8]: 10 Var[9]: 10 Var[10]: 10 Var[11]: 10 Var[12]: 10 Wrong</code>\nSo the problem looks simple, a simple keygen-me. Throw it to Hopper and</p>\n<p>`<code></code>c\nint main() {\nvar_28 = *0x28;\nprintf(\"Var[0]: \");</p>\n<pre><code>fflush(rax);\n__isoc99_scanf(0x402a11, var_60);\nprintf(0x402a14);\n\nfflush(rax);\n__isoc99_scanf(0x402a11, var_60 + 0x4);\nprintf(\"Var[2]: \");\n\nfflush(rax);\n__isoc99_scanf(0x402a11, var_60 + 0x8);\nprintf(\"Var[3]: \");\n\nfflush(rax);\n__isoc99_scanf(0x402a11, var_60 + 0xc);\nprintf(\"Var[4]: \");\n\nfflush(rax);\n__isoc99_scanf(0x402a11, var_60 + 0x10);\nprintf(\"Var[5]: \");\n\nfflush(rax);\n__isoc99_scanf(0x402a11, var_60 + 0x14);\nprintf(\"Var[6]: \");\n\nfflush(rax);\n__isoc99_scanf(0x402a11, var_60 + 0x18);\nprintf(\"Var[7]: \");\n\nfflush(rax);\n__isoc99_scanf(0x402a11, var_60 + 0x1c);\nprintf(\"Var[8]: \");\n\nfflush(rax);\n__isoc99_scanf(0x402a11, var_60 + 0x20);\nprintf(\"Var[9]: \");\n\nfflush(rax);\n__isoc99_scanf(0x402a11, var_60 + 0x24);\nprintf(\"Var[10]: \");\n\nfflush(rax);\n__isoc99_scanf(0x402a11, var_60 + 0x28);\nprintf(\"Var[11]: \");\n\nfflush(rax);\n__isoc99_scanf(0x402a11, var_60 + 0x2c);\nprintf(\"Var[12]: \");\n\nfflush(rax);\n__isoc99_scanf(0x402a11, var_60 + 0x30);\nif (CheckSolution(var_60) != 0x0) {\n        printf(\"The flag is: %c%c%c%c%c%c%c%c%c%c%c%c%c\\n\", var_60, var_5C, var_58, var_54, var_50, var_4C, var_48, var_44, var_40, var_3C, var_38, var_34, var_30);\n}\nelse {\n        puts(\"Wrong\");\n}\nrax = 0x0;\nrbx = var_28 ^ *0x28;\nCOND = rbx == 0x0;\nif (!COND) {\n        rax = __stack_chk_fail();\n}\nreturn rax;\n</code></pre>\n<p>}\n`<code></code></p>\n<p>So main function takes 13 variables and passes it to CheckSolution for verifying. Hopper gives a pretty ugly decompilation for CheckSolution. So without actually reversing and fishing out the constraints for the equations we turn to <a href=\"http://angr.io/\">angr</a>. The solution script is pretty straight. We set our target to find as the instruction which returns a non zero value from CheckSolution.</p>\n<p>`<code></code>python\nimport angr</p>\n<p>proj = angr.Project('./baby-re', load<em>options={\"auto</em>load<em>libs\": False})\ninitial</em>state = proj.factory.entry<em>state()\npath</em>group = proj.factory.path<em>group(initial</em>state)\npath_group.explore(find=0x4025cc)</p>\n<p>found = path<em>group.found[0]\nprint found.state.se.any</em>str(found.state.memory.load(found.state.regs.rbp, 200))\n`<code></code></p>\n<p>Running this for some 3-4 minutes on my machine will give us</p>\n<p><code>bash $ python solve.py Couldn't import dot_parser, loading of dot files will not be possible. ��������(@Math is hard!`\u0001`\u0001�@�������\u001c</code></p>\n<blockquote>\n<p>FLAG : Math is hard!</p>\n</blockquote>","relativePath":"writeups/defcon-ctf-qualifier-2016/babys-first/baby-re/sudhackar"}}