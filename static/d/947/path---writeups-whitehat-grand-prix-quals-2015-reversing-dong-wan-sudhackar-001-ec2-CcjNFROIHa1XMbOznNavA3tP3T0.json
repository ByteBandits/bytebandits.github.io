{"pageContext":{"html":"<p><a href=\"ctf=whitehat-grand-prix-quals-2015\"></a>\n<a href=\"type=analysis,reverse\"></a>\n<a href=\"tags=base64\"></a>\n<a href=\"tools=gdb-peda\"></a>\n<a href=\"techniques=\"></a></p>\n<h1>Dong Van (RE - 100)</h1>\n<p>So we have a <a href=\"/re100_35d14595b17756b79556f6eca775c31a-35d14595b17756b79556f6eca775c31a.zip\">zip</a>.</p>\n<pre><code class=\"language-bash\">$ file Re100\nRe100: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=6c7c0504ab2f342427f59846298e97f9e4fbb98f, not stripped\n\n$ ./Re100 \nInput your secret: AAAA\nToo bad :(\n</code></pre>\n<p>So its checking for a password. A strings on the binary will tell us.</p>\n<pre><code class=\"language-bash\">$ strings ./Re100\n.\n.\n\nstoull\n%llu\nELF8n0BKxOCbj/WU9mwle4cG6hytqD+P3kZ7AzYsag2NufopRSIVQHMXJri51Tdv\n0000\nInput your secret: \nms4otszPhcr7tMmzGMkHyFn=\nGood boy! Submit your flag :)\nToo bad :(\n.\n.\n</code></pre>\n<p>We see some base64 here. But it doesn't work. So we'll load it up in gdb.</p>\n<p>When we run it we see the input we pass is given on to a function change() and the output is matched with ms4otszPhcr7tMmzGMkHyFn=.\nSo this uses a custom encoding technique. Stepping through the program we see that the program uses 'ELF8n0BKxOCbj/WU9mwle4cG6hytqD+P3kZ7AzYsag2NufopRSIVQHMXJri51Tdv' as its character set in the same fasion as normal Base64.\nSo we write <a href=\"/re100-base64-custom-5b49eef60147d6181caa2324e8e6791a.c\">this</a>.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n#include &#x3C;string.h>\n\nchar b64[] = \"ELF8n0BKxOCbj/WU9mwle4cG6hytqD+P3kZ7AzYsag2NufopRSIVQHMXJri51Tdv\";\n\nvoid decodeblock(unsigned char in[], char *clrstr) {\n  unsigned char out[4];\n  out[0] = in[0] &#x3C;&#x3C; 2 | in[1] >> 4;\n  out[1] = in[1] &#x3C;&#x3C; 4 | in[2] >> 2;\n  out[2] = in[2] &#x3C;&#x3C; 6 | in[3] >> 0;\n  out[3] = '\\0';\n  strncat(clrstr, out, sizeof(out));\n}\n\nvoid b64_decode(char *b64src, char *clrdst) {\n  int c, phase, i;\n  unsigned char in[4];\n  char *p;\n\n  clrdst[0] = '\\0';\n  phase = 0; i=0;\n  while(b64src[i]) {\n    c = (int) b64src[i];\n    if(c == '=') {\n      decodeblock(in, clrdst); \n      break;\n    }\n    p = strchr(b64, c);\n    if(p) {\n      in[phase] = p - b64;\n      phase = (phase + 1) % 4;\n      if(phase == 0) {\n        decodeblock(in, clrdst);\n        in[0]=in[1]=in[2]=in[3]=0;\n      }\n    }\n    i++;\n  }\n}\n\nint main() {\n  char myb64[] = \"ms4otszPhcr7tMmzGMkHyFn=\";\n  char mydst[1024] = \"\";\n\n  b64_decode(myb64, mydst);\n  printf(\"%s\",mydst);\n\n  return 0;\n}\n</code></pre>\n<p>Which gives us </p>\n<blockquote>\n<p>Funny<em>encode</em>huh!</p>\n</blockquote>\n<p>Flag:</p>\n<blockquote>\n<p>WhiteHat{49a07ca9d78eefff4f3c7888eb1dedeb56b16f1c}</p>\n</blockquote>"}}