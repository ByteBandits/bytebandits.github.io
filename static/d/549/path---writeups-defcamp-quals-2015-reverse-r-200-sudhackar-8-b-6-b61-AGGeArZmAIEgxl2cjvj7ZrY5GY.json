{"pageContext":{"html":"<p><a href=\"ctf=defcamp-quals-2015\"></a>\n<a href=\"type=reverse\"></a>\n<a href=\"tags=hardcoded\"></a></p>\n<p>We are given a <a href=\"/r200-9d4e94c3f69ca15c35f2dd3bc1047e20.bin\">binary</a>.</p>\n<p><code>bash $ file r200.bin r200.bin: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=22e68980e521b43c90688ed0693df78150b10211, stripped</code></p>\n<p>This one has the same ptrace protection as in <a href=\"../../r100\">r100</a>.We use the same technique to bypass ptrace check.\n<code>bash gdb-peda$ b *0x40087d Breakpoint 1 at 0x40087d gdb-peda$ r . . gdb-peda$ set $rax=0</code>\nNow the decompiling doesn't help much. We move to manually testing the flow path of binary.</p>\n<p><code>asm mov DWORD PTR [rbp-0x20],0x5 mov DWORD PTR [rbp-0x1c],0x2 mov DWORD PTR [rbp-0x18],0x7 mov DWORD PTR [rbp-0x14],0x2 mov DWORD PTR [rbp-0x10],0x5 mov DWORD PTR [rbp-0xc],0x6</code>\nThis seems interesting. A little bit of analysis shows </p>\n<p><code>bash 0x4007af: mov rax,QWORD PTR [rip+0x2008ca] # 0x601080</code>\nOn examining memory at 0x601080 and nearby areas we see the obvious.</p>\n<p><code>bash gdb-peda$ x/2xw 0x602010 0x602010: 0x00000001 0x0000006e gdb-peda$ x/2xw 0x602030 0x602030: 0x00000002 0x0000006f gdb-peda$ x/2xw 0x602050 0x602050: 0x00000003 0x00000070 gdb-peda$ x/2xw 0x602070 0x602070: 0x00000004 0x00000071</code>\nWe see that 0x6e(n) is mapped to 0, 0x6f(o) to 2 and so on.\nso 5,2,7,2,5,6 gives us rotors</p>\n<p>Flag</p>\n<blockquote>\n<p>rotors</p>\n</blockquote>","relativePath":"writeups/defcamp-quals-2015/reverse/r200/sudhackar"}}