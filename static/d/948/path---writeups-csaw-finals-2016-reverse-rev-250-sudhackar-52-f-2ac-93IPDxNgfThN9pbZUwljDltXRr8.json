{"pageContext":{"html":"<p><a href=\"ctf=csaw-finals-2016\"></a>\n<a href=\"type=reverse\"></a>\n<a href=\"tags=z3,%20constraint%20solving\"></a>\n<a href=\"tools=z3\"></a>\n<a href=\"techniques=constraint%20solving,%20symbolic%20execution\"></a></p>\n<h1>packer (rev-250)</h1>\n<p>We are given a <a href=\"/packer-release-f382f28f0f43ffa92691b68aaf5006e8.\">file</a></p>\n<p><code>bash $file packer-release packer-release: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=30e7a8e386f33bb6bdf8a7701d7169584f9db7a9, stripped</code>\nOpening it in hopper gives a pretty neat decompilation.</p>\n<p>`<code></code>c\nmain() {\nesi = arg1;\nif (arg0 == 0x2) {\neax = malloc(0x1f);\nebx = eax;\n<em>0x804a034 = eax;\neax = *(esi + 0x4);\nstrncpy(ebx, eax, 0x1f);\n*(int8<em>t *)(ebx + 0x1e) = 0x0;\nedx = *(ebx + 0xd);\neax = *(ebx + 0x15);\nif (eax + edx == 0xe1d4e090) {\n*0x804a030 = *0x804a030 ^ 0xb93e4867;\n}\nif (eax + *(ebx + 0x19) == 0x94e860d0) {\n*0x804a030 = *0x804a030 ^ 0xb9f7a2ff;\n}\nesi = *(ebx + 0x9);\nif (esi + eax == 0xcdd6d8c1) {\n*0x804a030 = *0x804a030 ^ 0x7e3c14cd;\n}\necx = *(ebx + 0x11);\nif (ecx + *(ebx + 0x5) == 0x93e1a69f) {\n*0x804a030 = *0x804a030 ^ 0x21ddc691;\n}\nif (esi + edx == 0xcd929799) {\n*0x804a030 = *0x804a030 ^ 0x65aafd58;\n}\nif (eax + ecx == 0x9fa6cfd3) {\n*0x804a030 = *0x804a030 ^ 0x372f660e;\n}\nif (edx + ecx == 0xa490e3a5) {\n*0x804a030 = *0x804a030 ^ 0xcbff9345;\n}\nsub</em>8048513();\neax = *0x804a034;\necx = *(eax + 0x5);\nedx = *(eax + 0x19);\nesi = edx + ecx;\nif (esi == 0x55dc64d0) {\n*0x804a030 = *0x804a030 ^ 0x453057e3;\n}\nedi = *(</em>0x804a034 + 0x11);\nif (edi + edx == 0x5261e2d3) {\n<em>0x804a030 = *0x804a030 ^ 0xe8d28fd7;\n}\nebx = *(</em>0x804a034 + 0x9);\nif (edi + ebx == 0xcdd8a69f) {\n<em>0x804a030 = *0x804a030 ^ 0xce71dd4a;\n}\nif (esi == 0x5497e5c0) {\n*0x804a030 = *0x804a030 ^ 0xc30b088b;\n}\nesi = *(</em>0x804a034 + 0xd);\nif (esi + ecx == 0x939b9799) {\n<em>0x804a030 = *0x804a030 ^ 0xb2c58526;\n}\nif (ecx + *(</em>0x804a034 + 0x15) == 0xa1dcd2c0) {\n<em>0x804a030 = *0x804a030 ^ 0xa47e904c;\n}\nif (ebx + edx == 0x8fd364d0) {\n*0x804a030 = *0x804a030 ^ 0x4d663570;\n}\nif (ecx + ebx == 0x92c8dec3) {\n*0x804a030 = *0x804a030 ^ 0x5f3ceee9;\n}\nif (edx + esi == 0x80a79399) {\n*0x804a030 = *0x804a030 ^ 0xbd87bd77;\n}\nif (</em>0x804a030 == 0xdeadbea7) {\neax = sub<em>80484f0();\n}\nelse {\neax = sub</em>80484cd();\n}\n}\nelse {\nstack[2042] = *esi;\n_<em>printf</em>chk(0x1, \"usage: %s flag\\n\", stack[2042]);\neax = 0xffffffff;\n}\nreturn eax;\n}</p>\n<p>sub<em>8048513() {\nif ((((*(int8</em>t <em>)(</em>0x804a034 + 0x4) == 0x7b) &#x26;&#x26; (<em>(int8_t *)(</em>0x804a034 + 0x2) == 0x61)) &#x26;&#x26; (<em>(int8_t *)(</em>0x804a034 + 0x1) == 0x6c)) &#x26;&#x26; (<em>(int8_t *)</em>0x804a034 == 0x66)) {\nif (<em>(int8_t *)(</em>0x804a034 + 0x3) == 0x67) {\nif (<em>(int8_t *)(</em>0x804a034 + 0x1d) == 0x7d) {\n*0x804a030 = *0x804a030 ^ 0x35e4eebf;\n}\n}\n}\nreturn *0x804a034;\n}\n`<code></code></p>\n<p>The logic is pretty straight forward. main() checks if the flag is in argv[1] and then checks the constraints on it. sub_8048513() checks if the flag is of format flag{ %s} and then sets *0x804a030=0x35E4EEBF.</p>\n<p>Its very easy to figure out the constraints here. 0x804a030 stores a xor checksum which should be equal to 0xdeadbea7 for the correct flag.</p>\n<p>Since the remote hosts given to us were not so powerful to run angr and we did not have root on the local machines, I used z3 model this binary from the decompilation produced by hopper <a href=\"/rev250-05ba908739a21836392d848947b2ddf6.py\">here</a>.</p>\n<p>`<code></code>python\nfrom z3 import *</p>\n<p>for i in xrange(6):\nglobals()['a%i' % i]=BitVec('a%i' %i,32)</p>\n<p>for i in xrange(16):\nglobals()['xor_%i' % i]=BitVec('xor_%i' %i,32)</p>\n<p>solver=Solver()</p>\n<p>cons=[a2+a4 == 0xE1D4E090,a5+a4 == 0x94E860D0,a1+a4 == 0xCDD6D8C1,a0+a3 == 0x93E1A69F,a1+a2 == 0xCD929799,a3+a4 == 0x9FA6CFD3,a2+a3 == 0xA490E3A5,a0+a5 == 1440507088,a5+a3 == 1382146771,a1+a3 == 0xCDD8A69F,a0+a5 == 1419240896,a0+a2 == 0x939B9799,a4+a0 == 0xA1DCD2C0,a1+a5 == 0x8FD364D0,a1+a0 == 0x92C8DEC3,a2+a5 == 0x80A79399]\nxor_a=[0xB93E4867,0xB9F7A2FF,0x7E3C14CD,0x21DDC691,0x65AAFD58,0x372F660E,0xCBFF9345,0x453057E3,0xE8D28FD7,0xCE71DD4A,0xC30B088B,0xB2C58526,0xA47E904C,0x4D663570,0x5F3CEEE9,0xBD87BD77]</p>\n<p>for i in xrange(16):\nglobals()['xor_%i' % i]=xor_a[i]</p>\n<p>xor_w=BitVecVal(0x35E4EEBF,32)</p>\n<p>temp=BitVec('temp',32)</p>\n<p>for i in xrange(16):\ntemp=xor<em>w^globals()['xor</em>%i' % i]\nxor<em>w=If((cons[i]),temp,xor</em>w)</p>\n<p>solver.add(xor_w == 0xDEADBEA7)</p>\n<p>print solver.check()</p>\n<p>modl=solver.model()</p>\n<p>res=\"\"\nfor i in xrange(6):\nobj=globals()['a%i' % i]\nc=modl[obj].as_long()\nres += hex(c)[2:].decode('hex')[::-1]</p>\n<p>print(\"Result: flag{ %s}\"%res)\n`<code></code></p>\n<p>gives us flag{alg3bra<em>1z</em>sti11<em>fun</em>y0!} in no time.</p>","relativePath":"writeups/csaw-finals-2016/reverse/rev250/sudhackar"}}