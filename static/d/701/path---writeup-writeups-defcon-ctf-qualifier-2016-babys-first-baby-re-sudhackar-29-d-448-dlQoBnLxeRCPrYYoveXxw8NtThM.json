{"pageContext":{"html":"<p><a href=\"ctf=defcon-qualifier-2015\"></a>\n<a href=\"type=reverse\"></a>\n<a href=\"tags=equation-solver\"></a>\n<a href=\"tools=angr\"></a></p>\n<h1>baby-re (babys-first 1)</h1>\n<h3><del>math required</del></h3>\n<p>We are given a file</p>\n<pre><code class=\"language-bash\">$ file baby-re\nbaby-re: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=5d5783d23d78bf70b80d658bccbce365f7448693, not stripped\n</code></pre>\n<p>Test-run</p>\n<pre><code class=\"language-bash\">$ ./baby-re\nVar[0]: 10\nVar[1]: 10\nVar[2]: 10\nVar[3]: 101\nVar[4]: 10\nVar[5]: 10\nVar[6]: 10\nVar[7]: 10\nVar[8]: 10\nVar[9]: 10\nVar[10]: 10\nVar[11]: 10\nVar[12]: 10\nWrong\n</code></pre>\n<p>So the problem looks simple, a simple keygen-me. Throw it to Hopper and</p>\n<pre><code class=\"language-c\">int main() {\n    var_28 = *0x28;\n    printf(\"Var[0]: \");\n\n    fflush(rax);\n    __isoc99_scanf(0x402a11, var_60);\n    printf(0x402a14);\n\n    fflush(rax);\n    __isoc99_scanf(0x402a11, var_60 + 0x4);\n    printf(\"Var[2]: \");\n\n    fflush(rax);\n    __isoc99_scanf(0x402a11, var_60 + 0x8);\n    printf(\"Var[3]: \");\n\n    fflush(rax);\n    __isoc99_scanf(0x402a11, var_60 + 0xc);\n    printf(\"Var[4]: \");\n\n    fflush(rax);\n    __isoc99_scanf(0x402a11, var_60 + 0x10);\n    printf(\"Var[5]: \");\n\n    fflush(rax);\n    __isoc99_scanf(0x402a11, var_60 + 0x14);\n    printf(\"Var[6]: \");\n\n    fflush(rax);\n    __isoc99_scanf(0x402a11, var_60 + 0x18);\n    printf(\"Var[7]: \");\n\n    fflush(rax);\n    __isoc99_scanf(0x402a11, var_60 + 0x1c);\n    printf(\"Var[8]: \");\n\n    fflush(rax);\n    __isoc99_scanf(0x402a11, var_60 + 0x20);\n    printf(\"Var[9]: \");\n\n    fflush(rax);\n    __isoc99_scanf(0x402a11, var_60 + 0x24);\n    printf(\"Var[10]: \");\n\n    fflush(rax);\n    __isoc99_scanf(0x402a11, var_60 + 0x28);\n    printf(\"Var[11]: \");\n\n    fflush(rax);\n    __isoc99_scanf(0x402a11, var_60 + 0x2c);\n    printf(\"Var[12]: \");\n\n    fflush(rax);\n    __isoc99_scanf(0x402a11, var_60 + 0x30);\n    if (CheckSolution(var_60) != 0x0) {\n            printf(\"The flag is: %c%c%c%c%c%c%c%c%c%c%c%c%c\\n\", var_60, var_5C, var_58, var_54, var_50, var_4C, var_48, var_44, var_40, var_3C, var_38, var_34, var_30);\n    }\n    else {\n            puts(\"Wrong\");\n    }\n    rax = 0x0;\n    rbx = var_28 ^ *0x28;\n    COND = rbx == 0x0;\n    if (!COND) {\n            rax = __stack_chk_fail();\n    }\n    return rax;\n}\n</code></pre>\n<p>So main function takes 13 variables and passes it to CheckSolution for verifying. Hopper gives a pretty ugly decompilation for CheckSolution. So without actually reversing and fishing out the constraints for the equations we turn to <a href=\"http://angr.io/\">angr</a>. The solution script is pretty straight. We set our target to find as the instruction which returns a non zero value from CheckSolution.</p>\n<pre><code class=\"language-python\">import angr\n\nproj = angr.Project('./baby-re', load_options={\"auto_load_libs\": False})\ninitial_state = proj.factory.entry_state()\npath_group = proj.factory.path_group(initial_state)\npath_group.explore(find=0x4025cc)\n\nfound = path_group.found[0]\nprint found.state.se.any_str(found.state.memory.load(found.state.regs.rbp, 200))\n</code></pre>\n<p>Running this for some 3-4 minutes on my machine will give us</p>\n<pre><code class=\"language-bash\">$ python solve.py\nCouldn't import dot_parser, loading of dot files will not be possible.\n��������(@Math is hard!`\u0001`\u0001�@�������\u001c\n</code></pre>\n<blockquote>\n<p>FLAG : Math is hard!</p>\n</blockquote>"}}