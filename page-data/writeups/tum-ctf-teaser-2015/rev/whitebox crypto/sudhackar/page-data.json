{"componentChunkName":"component---src-templates-writeup-js","path":"/writeups/tum-ctf-teaser-2015/rev/whitebox crypto/sudhackar","result":{"pageContext":{"html":"<p><a href=\"ctf=tum-ctf-teaser-2015\"></a>\n<a href=\"type=rev\"></a>\n<a href=\"tags=xtea\"></a>\n<a href=\"tool=pwntools\"></a></p>\n<h1>whitebox crypto (rev 20)</h1>\n<p>So we have an <a href=\"/293e91f132fabcb91d8976185d5c303a/xtea.\">executable</a></p>\n<p>Problem statement</p>\n<pre><code>Do not panic, it's only XTEA! I wonder what the key was...\n</code></pre>\n<p>Little bit of google we get this piece of code from <a href=\"https://en.wikipedia.org/wiki/XTEA\">Wikipedia</a></p>\n<pre><code class=\"language-c\">void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) {\n    unsigned int i;\n    uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9;\n    for (i=0; i &#x3C; num_rounds; i++) {\n        v0 += (((v1 &#x3C;&#x3C; 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum &#x26; 3]);\n        sum += delta;\n        v1 += (((v0 &#x3C;&#x3C; 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum>>11) &#x26; 3]);\n    }\n    v[0]=v0; v[1]=v1;\n}\n</code></pre>\n<p>Given file</p>\n<pre><code class=\"language-bash\">$ file ./xtea\n./xtea: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=331f96cc8eefbf07d5752cf9e8cf4facb32ba8ff, not stripped\n</code></pre>\n<p>A little bit of analysis shows we have to give something as argv[1] of length 16 as input</p>\n<pre><code class=\"language-bash\">$ ./xtea AAAAAAAAAAAAAAAA\n4a584fe6 116e650b\n</code></pre>\n<p>It returns the input \"encrypted\". We have to find the key.\nThe code from Wikipedia says key[4] would be having 4 blocks of length 4. So the key is of length 16.\nsum=0 at the start of the process and it cumulatively adds delta to it which is added to key[i] in some fashion.\nWe see an encipher function in the file.</p>\n<pre><code class=\"language-objdump\">gdb-peda$ pdisass encipher\nDump of assembler code for function encipher:\n   0x00000000004005a0 &#x3C;+0>:     mov    ecx,DWORD PTR [rdi+0x4]\n   0x00000000004005a3 &#x3C;+3>:     push   r12\n   0x00000000004005a5 &#x3C;+5>:     push   rbp\n   0x00000000004005a6 &#x3C;+6>:     push   rbx\n   0x00000000004005a7 &#x3C;+7>:     mov    edx,ecx\n   0x00000000004005a9 &#x3C;+9>:     mov    eax,ecx\n   0x00000000004005ab &#x3C;+11>:    shr    edx,0x5\n   0x00000000004005ae &#x3C;+14>:    shl    eax,0x4\n   0x00000000004005b1 &#x3C;+17>:    xor    eax,edx\n   0x00000000004005b3 &#x3C;+19>:    add    eax,ecx\n   0x00000000004005b5 &#x3C;+21>:    xor    eax,0x7b707868\n   0x00000000004005ba &#x3C;+26>:    add    eax,DWORD PTR [rdi]\n   0x00000000004005bc &#x3C;+28>:    mov    r10d,eax\n   0x00000000004005bf &#x3C;+31>:    mov    edx,eax\n   0x00000000004005c1 &#x3C;+33>:    shl    eax,0x4\n   0x00000000004005c4 &#x3C;+36>:    shr    r10d,0x5\n   0x00000000004005c8 &#x3C;+40>:    xor    r10d,eax\n   0x00000000004005cb &#x3C;+43>:    add    r10d,edx\n   0x00000000004005ce &#x3C;+46>:    xor    r10d,0x1b58ea2e\n   0x00000000004005d5 &#x3C;+53>:    lea    r11d,[r10+rcx*1]\n   0x00000000004005d9 &#x3C;+57>:    mov    r9d,r11d\n   0x00000000004005dc &#x3C;+60>:    mov    eax,r11d\n   0x00000000004005df &#x3C;+63>:    shl    eax,0x4\n   0x00000000004005e2 &#x3C;+66>:    shr    r9d,0x5\n   0x00000000004005e6 &#x3C;+70>:    xor    r9d,eax\n   0x00000000004005e9 &#x3C;+73>:    add    r9d,r11d\n   0x00000000004005ec &#x3C;+76>:    xor    r9d,0xba9ae30\n   0x00000000004005f3 &#x3C;+83>:    lea    eax,[r9+rdx*1]\n   0x00000000004005f7 &#x3C;+87>:    mov    r12d,eax\n   0x00000000004005fa &#x3C;+90>:    mov    edx,eax\n   0x00000000004005fc &#x3C;+92>:    shl    edx,0x4\n   0x00000000004005ff &#x3C;+95>:    shr    r12d,0x5\n   0x0000000000400603 &#x3C;+99>:    xor    r12d,edx\n   0x0000000000400606 &#x3C;+102>:   add    r12d,eax\n   0x0000000000400609 &#x3C;+105>:   xor    r12d,0x9bd661db\n   0x0000000000400610 &#x3C;+112>:   lea    r10d,[r12+r11*1]\n   0x0000000000400614 &#x3C;+116>:   mov    r8d,r10d\n   0x0000000000400617 &#x3C;+119>:   mov    edx,r10d\n   0x000000000040061a &#x3C;+122>:   shl    edx,0x4\n   0x000000000040061d &#x3C;+125>:   shr    r8d,0x5\n   0x0000000000400621 &#x3C;+129>:   xor    r8d,edx\n   0x0000000000400624 &#x3C;+132>:   add    r8d,r10d\n   0x0000000000400627 &#x3C;+135>:   xor    r8d,0x9bd661db\n   0x000000000040062e &#x3C;+142>:   lea    r9d,[r8+rax*1]\n   0x0000000000400632 &#x3C;+146>:   mov    ebp,r9d\n   0x0000000000400635 &#x3C;+149>:   mov    eax,r9d\n   0x0000000000400638 &#x3C;+152>:   shl    eax,0x4\n   0x000000000040063b &#x3C;+155>:   shr    ebp,0x5\n   0x000000000040063e &#x3C;+158>:   xor    ebp,eax\n   0x0000000000400640 &#x3C;+160>:   add    ebp,r9d\n   0x0000000000400643 &#x3C;+163>:   xor    ebp,0x4818a1a2\n   0x0000000000400649 &#x3C;+169>:   lea    r12d,[rbp+r10*1+0x0]\n   .\n   .\n   .\n</code></pre>\n<p>Looking at it we can say the key is hardcoded here.\nSo we start with sum=0 and keep it increasing by delta .The hardcoded values in hex are (sum + key[sum &#x26; 3]) and (sum + key[(sum>>11) &#x26; 3])\nLittle bit of unpacking to do.</p>\n<pre><code class=\"language-python\">>>> from pwn import *\n>>> p32(0x7b707868)\n'hxp{'\n>>> delta=0x9e3779b9\n>>> p32((0x1b58ea2e-delta)&#x26;0xffffffff)\n'up!}'\n>>> p32((0xba9ae30-delta)&#x26;0xffffffff)\n'w4rm'\n>>> p32((0x9bd661db-delta*2)&#x26;0xffffffff)\n'ing_'\n</code></pre>\n<p>gives us flag</p>\n<blockquote>\n<p>hxp{w4rming_up!}</p>\n</blockquote>","relativePath":"writeups/tum-ctf-teaser-2015/rev/whitebox crypto/sudhackar"}}}