{"componentChunkName":"component---src-templates-writeup-js","path":"/writeups/watevr-2019/rev/hacking-for-vodka/vn-ki","result":{"pageContext":{"html":"<h1>Hacking for vodka</h1>\n<h4>Category: rev</h4>\n<h4>Points: 56</h4>\n<p>This was a relatively easy chall as you can see with the points.</p>\n<p>The following is the decompiled check.</p>\n<pre><code class=\"language-c\">  while (i &#x3C; n) {\n    local_4c = pass[i]; // input byte\n    local_4b = 0;\n    local_4a = (byte)i ^ *(byte *)(enc + i); // flag byte\n    local_49 = 0;\n    (&#x26;uStack144)[uVar1 * 0x1ffffffffffffffe] = 0x555555554c1d;\n    __n = strcmp(&#x26;local_4c,&#x26;local_4a,*(undefined *)(&#x26;uStack144 + uVar1 * 0x1ffffffffffffffe));\n    if (__n != 0) {\n      (&#x26;uStack144)[uVar1 * 0x1ffffffffffffffe] = 0x555555554c2d;\n      puts(\"Sorry, incorrect password!\",*(undefined *)(&#x26;uStack144 + uVar1 * 0x1ffffffffffffffe));\n                    /* WARNING: Subroutine does not return */\n      (&#x26;uStack144)[uVar1 * 0x1ffffffffffffffe] = 0x555555554c37;\n      exit(0,*(undefined *)(&#x26;uStack144 + uVar1 * 0x1ffffffffffffffe));\n    }\n    i = i + 1;\n  }\n</code></pre>\n<p>Our input is checked byte by byte with the flag. (Also there is a ptrace check at the start, and this can be patched out)</p>\n<p>There are two easy methods I discovered after getting the flag using my method:</p>\n<ul>\n<li>Bruteforce ltrace the flag out, figuring out the flag byte by byte.</li>\n<li>Patch the incorrect password jump and provide an incorrect flag, thus getting the whole flag.</li>\n</ul>\n<p>I spoke with the chall author and this was not the intended solution. They should've statically compiled or used <code>==</code> instead of strcmp.</p>\n<p>Now onto my solution. If you look at the disassembly,</p>\n<pre><code class=\"language-asm\">   ADD          RAX,param_3\n   MOVZX        param_3,byte ptr [RAX]\n   MOV          EAX,dword ptr [RBP + i]\n   XOR          EAX,param_3\n   MOV          byte ptr [RBP + local_4a],AL\n</code></pre>\n<p>As you can see, the current byte of the flag is stored in <code>eax</code>. So we could just fetch the current byte everytime dynamically and thus have the whole flag.</p>\n<p>I wrote an r2pipe python script to do this.</p>\n<pre><code class=\"language-python\">import r2pipe\n\np = r2pipe.open('./vodka')\n\n# disable aslr, provide a fake flag\np.cmd('dor aslr=no,stdin=\"AAA\"')\n# reopen in debug mode\np.cmd('doo')\np.cmd('aa')\n\n\nres = []\nbps = [\n    0x555555555304,\n    0x555555554c03,\n    0x555555554c21\n]\n\nfor i in bps:\n    p.cmd('db '+hex(i))\n\n# when the check for input occurs, circumvent it\np.cmd('dbc 0x555555554c21 dr rip=0x555555554c37')\n\np.cmd('dc')\n# circumvent ptrace check\np.cmd('dr rip=0x555555555312')\np.cmd('dc')\n\nwhile True:\n    rax = p.cmdj('drj')['rax']\n    if rax > 255:\n        break\n    res.append(rax)\n    p.cmd('dc')\n    p.cmd('dc')\n\nprint(res)\nprint(''.join(chr(i) for i in res))\n</code></pre>","relativePath":"writeups/watevr-2019/rev/hacking-for-vodka/vn-ki"}}}